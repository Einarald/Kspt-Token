<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Snake Game - KSPT</title>
<style>
:root { --accent: #00bcd4; --accent-2: #00e676; --bg:#111; --panel:#0b0b0b; }
*{box-sizing:border-box}
body{margin:0;padding:0;background:#000;color:#fff;font-family:Arial, sans-serif;overflow:hidden;}
.game-container{display:flex;flex-direction:column;align-items:center;height:100vh;padding:10px;background:linear-gradient(135deg,var(--panel) 0%, #1a1a1a 100%);}
.game-header{display:flex;justify-content:space-between;width:100%;margin-bottom:10px;padding:10px;background:rgba(0,0,0,0.45);border-radius:10px;border:1px solid var(--accent);}
.game-title{color:var(--accent-2);font-weight:bold;font-size:18px}
.game-stats{display:flex;gap:15px;font-size:14px}
canvas{ background:var(--bg); border:2px solid var(--accent); border-radius:10px; image-rendering:pixelated; display:block }
.joystick-container{position:relative;width:150px;height:150px;margin-top:20px}
.joystick-bg{width:100%;height:100%;background:rgba(0,188,212,0.08);border-radius:50%;position:relative;border:2px solid var(--accent)}
.joystick-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:40px;height:40px;background:var(--accent);border-radius:50%;box-shadow:0 0 10px rgba(0,188,212,0.5)}
.game-buttons{display:flex;gap:10px;margin-top:20px;width:100%;justify-content:center}
.game-buttons button{padding:12px 22px;background:linear-gradient(135deg,#00e5ff,#00bcd4);color:#000;border:none;border-radius:12px;cursor:pointer;font-weight:bold;font-size:15px;letter-spacing:0.5px;box-shadow:0 0 10px rgba(0,188,212,0.6), inset 0 0 6px rgba(255,255,255,0.3);transition:transform .12s ease,box-shadow .12s ease,filter .12s ease;}
.game-buttons button:hover{filter:brightness(1.12)}
.game-buttons button:active{transform:scale(.95);box-shadow:0 0 4px rgba(0,188,212,0.4), inset 0 0 10px rgba(0,0,0,0.3)}
.game-over{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.9);padding:30px;border-radius:15px;border:2px solid var(--accent-2);text-align:center;z-index:100;width:80%;max-width:320px}
.game-over h2{color:#ff4081;margin-top:0}
.earned{color:var(--accent-2);font-weight:bold;font-size:24px;margin:15px 0}
</style>
</head>
<body>
<div class="game-container">
    <div class="game-header">
        <div class="game-title">üêç Snake Game ‚Äî KSPT (upgraded)</div>
        <div class="game-stats">
            <div>Score: <span id="score">0</span></div>
            <div>Length: <span id="length">3</span></div>
            <div>Speed: <span id="speed">50%</span></div>
        </div>
    </div>

    <canvas id="gameCanvas" width="360" height="360"></canvas>

    <div class="joystick-container" id="joystickArea">
        <div class="joystick-bg"><div class="joystick-center"></div></div>
    </div>

    <div class="game-buttons">
        <button id="pauseBtn">Pause</button>
        <button id="restartBtn">Restart (-1)</button>
        <button id="exitBtn">Exit</button>
    </div>
</div>

<div class="game-over" id="gameOverScreen">
    <h2>Game Over!</h2>
    <div>Final Score: <span id="finalScore">0</span></div>
    <div>Snake Length: <span id="finalLength">3</span></div>
    <div class="earned">+<span id="earnedKSPT">0.00</span> KSPT</div>
    <div class="earned">+<span id="earnedEK">0</span> EK</div>
    <button id="playAgainBtn" style="background:#00e676;margin-bottom:10px">Play Again</button>
    <button id="exitToMenuBtn" style="background:#ff4081">Exit to Menu</button>
</div>

<script>

/* ===== helper: –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–∏–ª–µ—Ç–æ–≤ (localStorage) ===== */
function getLocalTicketCount() {
  try {
    const raw = localStorage.getItem('kspt_tickets');
    if (!raw) return null;
    const data = JSON.parse(raw);
    if (data && typeof data.current === 'number') return data.current;
    // –∏–Ω–æ–≥–¥–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –±—ã–ª–∞ { current: N } –∏–ª–∏ { current: "N" }
    if (data && data.current != null) return Number(data.current) || 0;
  } catch (e) {
    // –µ—Å–ª–∏ iframe cross-origin ‚Äî –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ—á–∏—Ç–∞—Ç—å, –≤–µ—Ä–Ω—ë–º null (–Ω–µ –º–µ—à–∞–µ–º)
    return null;
  }
  return null;
}

function ensureHasTicketOrWarn() {
  const c = getLocalTicketCount();
  if (c === null) {
    // –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å ‚Äî —Ä–∞–∑—Ä–µ—à–∞–µ–º —Ä–µ—Å—Ç–∞—Ä—Ç (—Ä–æ–¥–∏—Ç–µ–ª—å –º–æ–∂–µ—Ç –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞—Ç—å)
    return true;
  }
  if (c <= 0) {
    // –µ—Å–ª–∏ –µ—Å—Ç—å postMessage handler ‚Äî —Å–æ–æ–±—â–∏–º —Ä–æ–¥–∏—Ç–µ–ª—é
    try { (window.parent || window.top).postMessage({ type: 'kspt_no_tickets' }, '*'); } catch(e){}
    // –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ / —Ç–æ—Å—Ç
    try { showToast && showToast("Not enough tickets!"); } catch(e){ alert("Not enough tickets!"); }
    return false;
  }
  return true;
}

/* ========== GAME CONFIG ========== */
// === safer parent access helpers ===
function isSameOrigin(win) {
  try {
    void win.location.href;
    return true;
  } catch (e) {
    return false;
  }
}

// –≤–Ω—É—Ç—Ä–∏ –∏–≥—Ä—ã (snake.html / pingpong.html)
window.__kspt_hourly = window.__kspt_hourly || 0;

window.addEventListener('message', (ev) => {
  const msg = ev.data;
  if (!msg || typeof msg !== 'object') return;

  if (msg.type === 'kspt_init' || msg.type === 'kspt_hourly_update') {
    const h = Number(msg.hourly) || 0;
    window.__kspt_hourly = h;
  }

  if (msg.type === 'kspt_no_tickets') {
  gameRunning = false;
  gamePaused = true;

  // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º Game Over —ç–∫—Ä–∞–Ω
  const gos = document.getElementById('gameOverScreen');
  if (gos) gos.style.display = 'block';

  alert("Not enough tickets!");
}

  if (msg.type === 'kspt_parent_set_game_over' && msg.blockButtons) {
    document.getElementById('pauseBtn')?.setAttribute('disabled','true');
    document.getElementById('restartBtn')?.setAttribute('disabled','true');
    document.getElementById('exitBtn')?.setAttribute('disabled','true');
  }
});

function safeGetOfflinePercent(percent) {
  try {
    if (typeof HOST !== 'undefined' && HOST !== window && typeof HOST.getOfflinePercent === 'function') {
      return Number(HOST.getOfflinePercent(percent)) || 0;
    }
  } catch (e) { /* ignore */ }

  if (typeof window.__kspt_hourly === 'number') {
    return Math.round((window.__kspt_hourly * (percent/100)) * 100) / 100;
  }

  try {
    const raw = localStorage.getItem('kspt_data') || localStorage.getItem('d') || null;
    if (raw) {
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed.offlineHourly === 'number') {
        return Math.round((parsed.offlineHourly * (percent/100)) * 100) / 100;
      }
    }
  } catch(e) {}

  return 0;
}

function safeAwardGameReward(amount, x = 0, y = 0) {
  try {
    if (window.top && window.top !== window && isSameOrigin(window.top) && typeof window.top.awardGameReward === 'function') {
      window.top.awardGameReward(Number(amount) || 0, x || 0, y || 0);
      return;
    }
  } catch (e) {
    console.warn('safeAwardGameReward direct call failed', e);
  }

  try {
    (window.parent || window.top).postMessage({ type: 'kspt_award_reward', reward: Number(amount) || 0, x: x || 0, y: y || 0 }, '*');
    return;
  } catch (e) {
    console.warn('safeAwardGameReward postMessage failed', e);
  }

  console.log('Local reward fallback:', amount, x, y);
}

function safeAwardGameEK(amount, x = 0, y = 0) {
  try {
    if (window.top && window.top !== window && isSameOrigin(window.top) && typeof window.top.awardGameEK === 'function') {
      window.top.awardGameEK(Number(amount) || 0, x, y);
      return;
    }
  } catch(e) {}
  try {
    (window.parent || window.top).postMessage({ type: 'ek_award', amount: Number(amount)||0, x, y }, '*');
    return;
  } catch(e){}
  console.log('Local EK fallback', amount, x, y);
}

function safeConsumeTicket() {
  try {
    if (window.top && window.top !== window && isSameOrigin(window.top) && typeof window.top.consumeTicketForCurrentGame === 'function') {
      window.top.consumeTicketForCurrentGame();
      return;
    }
  } catch (e) {
    console.warn('safeConsumeTicket direct call failed', e);
  }

  try {
    (window.parent || window.top).postMessage({ type: 'kspt_consume_ticket' }, '*');
    return;
  } catch (e) {
    console.warn('safeConsumeTicket postMessage failed', e);
  }

  console.log('consumeTicket fallback (no parent handler)');
}

function safePlaySound(name) {
  // 1) –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—é (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
  try {
    if (window.top && window.top !== window && isSameOrigin(window.top) && typeof window.top.playSound === 'function') {
      window.top.playSound(name);
      return;
    }
  } catch (e) {
    console.warn('safePlaySound direct call failed', e);
  }

  // 2) –õ–æ–∫–∞–ª—å–Ω—ã–π WebAudio fallback (–Ω–∏–∫–∞–∫–∏—Ö —Ñ–∞–π–ª–æ–≤)
  try {
    if (!window._localAudioCtx) {
      window._localAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    const ctx = window._localAudioCtx;

    // –ü–æ–ø—ã—Ç–∫–∞ —Ä–∞–∑–±—É–¥–∏—Ç—å –∞—É–¥–∏–æ–∫–æ–Ω—Ç–µ–∫—Å—Ç (–µ—Å–ª–∏ –æ–Ω –≤ suspended)
    if (ctx.state === 'suspended' && typeof ctx.resume === 'function') {
      ctx.resume().catch(()=>{ /* –º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å user gesture */ });
    }

    const now = ctx.currentTime;

    if (name === 'apple') {
      // –ó–≤—É–∫ "—Å–æ–±–∏—Ä–∞–Ω–∏—è" ‚Äî –±—ã—Å—Ç—Ä—ã–π –∫–æ—Ä–æ—Ç–∫–∏–π –≤—Å–ø–ª–µ—Å–∫ —Å –ø–∞–¥–∞–Ω–∏–µ–º —á–∞—Å—Ç–æ—Ç—ã
      const o = ctx.createOscillator();
      const g = ctx.createGain();

      o.type = 'square';
      o.frequency.setValueAtTime(900, now);
      // —á—É—Ç—å –ø–æ–Ω–∏–∂–∞–µ–º —á–∞—Å—Ç–æ—Ç—É ‚Äî –∑–≤—É—á–∏—Ç '–ø–æ–ø'
      o.frequency.exponentialRampToValueAtTime(520, now + 0.12);

      g.gain.setValueAtTime(0.0, now);
      g.gain.linearRampToValueAtTime(0.18, now + 0.008);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.26);

      // –Ω–µ–±–æ–ª—å—à–æ–π —à—É–º (–±–µ–ª—ã–π) –¥–ª—è –æ—â—É—â–µ–Ω–∏—è "—Å–±–æ—Ä–∫–∏" (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Ç–æ–Ω–∫–æ)
      const noiseGain = ctx.createGain();
      const bufferSize = 2 * ctx.sampleRate;
      const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1) * 0.4;
      const noise = ctx.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = false;

      // –°–µ—Ç–∞–ø —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
      o.connect(g);
      noise.connect(noiseGain);
      // —Å–º–µ—à–∞–µ–º —Å–∏–Ω—É—Å/–∫–≤–∞–¥—Ä–∞—Ç –∏ —Å–ª–∞–±—ã–π —à—É–º
      const merger = ctx.createGain();
      g.connect(merger);
      noiseGain.gain.setValueAtTime(0.02, now);
      noiseGain.connect(merger);
      merger.connect(ctx.destination);

      // –∑–∞–ø—É—Å—Ç–∏—Ç—å
      o.start(now);
      noise.start(now);
      // –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —á–µ—Ä–µ–∑ ~0.26s
      o.stop(now + 0.26);
      noise.stop(now + 0.26);

      // –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –≥–µ–π–Ω–∞ (–Ω–∞ —Å–ª—É—á–∞–π)
      setTimeout(()=>{ try { g.disconnect(); noiseGain.disconnect(); } catch(e){} }, 400);
      return;
    }

    // fallback generic click/pop
    {
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.setValueAtTime(1200, now);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.16, now + 0.005);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      o.connect(g); g.connect(ctx.destination);
      o.start(now); o.stop(now + 0.18);
      return;
    }

  } catch (e) {
    console.warn('safePlaySound local WebAudio failed', e);
  }
}
  
/* ========== GAME variables ========== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gridSize = 18; 
const gridWidth = 20;
const gridHeight = 20;

const scoreEl = document.getElementById('score');
const lengthEl = document.getElementById('length');
const speedEl = document.getElementById('speed');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreEl = document.getElementById('finalScore');
const finalLengthEl = document.getElementById('finalLength');
const earnedKSPTEl = document.getElementById('earnedKSPT');
const earnedEKElem = document.getElementById('earnedEK');

// session EK (–ª–æ–∫–∞–ª—å–Ω–æ, –¥–ª—è –ø–æ–∫–∞–∑–∞ –≤ Game Over)
let sessionEK = 0;

// –∫–∞—Ä—Ç–∏–Ω–∫–∏ –∏ —è–≤–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ apple
const appleImg = new Image();
appleImg.src = 'kspt.png';      // <- –ø—É—Ç—å –∫ –∫–∞—Ä—Ç–∏–Ω–∫–µ KSPT
const appleImgEK = new Image();
appleImgEK.src = 'ek.png';      // <- –ø—É—Ç—å –∫ EK –∫–∞—Ä—Ç–∏–Ω–∫–µ

let apple; // —è–≤–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π apple (–≤–∞–∂–Ω–æ)

const startX = Math.floor(gridWidth / 2);
const startY = Math.floor(gridHeight / 2);

let snake = [
  {x:startX, y:startY},
  {x:startX-1, y:startY},
  {x:startX-2, y:startY}
];

do {
  apple = {
    x: Math.floor(Math.random()*gridWidth),
    y: Math.floor(Math.random()*gridHeight)
  };
  // ‚≠ê 3% —à–∞–Ω—Å —á—Ç–æ —ç—Ç–æ EK —è–±–ª–æ–∫–æ
  apple.isEK = Math.random() < 0.03;
} while (snake.some(s => s.x === apple.x && s.y === apple.y));

let direction = {x:1,y:0};
let score = 0;
let snakeLength = 3;
let moveInterval = 170;
let gameRunning = true;
let gamePaused = false;

let animationId = null;
let lastTimestamp = 0;
let accumulator = 0;

const floatingTexts = [];
let canVibrate = false;

/* helpers */
function spawnFloatingText(text, canvasX, canvasY, color = '#00e676') {
    floatingTexts.push({text, x: canvasX, y: canvasY, alpha:1, rise:0, color});
}

function safeVibrate(pattern){
    if (canVibrate && navigator.vibrate) navigator.vibrate(pattern);
}

/* togglePause (restored) */
function togglePause() {
    if (!gameRunning) return;
    gamePaused = !gamePaused;
    document.getElementById('pauseBtn').textContent = gamePaused ? 'Resume' : 'Pause';
}

/* single step logic */
function step(){
    const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};

    // wall collision
    if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
        gameOver(); return;
    }
    // self collision
    for (let seg of snake) if (seg.x===head.x && seg.y===head.y) { gameOver(); return; }

    snake.unshift(head);

    if (head.x === apple.x && head.y === apple.y) {
        // eaten
        score++; snakeLength++;
        moveInterval = Math.max(50, moveInterval - 2); // speed up
        updateUI();

        // reward calc ‚Äî –ø—Ä–∏ —Å—ä–µ–¥–∞–Ω–∏–∏ —è–±–ª–æ–∫–∞ –¥–∞—ë–º 1.3% –æ—Ç offline income
        const reward = safeGetOfflinePercent(1.8) || 0;

        window.__kspt_earnedKSPT = window.__kspt_earnedKSPT || 0;
        window.__kspt_earnedKSPT += reward;

        const cx = apple.x * gridSize + gridSize/2;
        const cy = apple.y * gridSize + gridSize/2;
        spawnFloatingText(`+${reward.toFixed(2)}`, cx, cy, '#00e676');

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—É—é –æ–±—ë—Ä—Ç–∫—É –¥–ª—è –Ω–∞–≥—Ä–∞–¥—ã
        try {
            const crect = canvas.getBoundingClientRect();
            safeAwardGameReward(reward, crect.left + cx, crect.top + cy);
        } catch(e){
            console.warn('safeAwardGameReward call failed in step', e);
        }

        // –µ—Å–ª–∏ —ç—Ç–æ EK-—è–±–ª–æ–∫–æ ‚Äî –≤—ã–¥–∞—ë–º +1 EK
        if (apple.isEK) {
          sessionEK++;
          safeAwardGameEK(1, apple.x * gridSize, apple.y * gridSize);
          spawnFloatingText('+1 EK', apple.x * gridSize + 6, apple.y * gridSize + 6, '#ffd54f');
        }

        safePlaySound('apple');
        safeVibrate(30);

        // place new apple not on snake
        do {
            apple = {
              x: Math.floor(Math.random()*gridWidth),
              y: Math.floor(Math.random()*gridHeight)
            };
            // —à–∞–Ω—Å 3% —á—Ç–æ —ç—Ç–æ EK-—è–±–ª–æ–∫–æ
            apple.isEK = Math.random() < 0.03;
        } while (snake.some(s=>s.x===apple.x && s.y===apple.y));
    } else {
        snake.pop();
    }
}

/* draw */
function draw(){
    ctx.fillStyle = '#111'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid
    ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
    for (let i=0;i<=gridWidth;i++){ ctx.beginPath(); ctx.moveTo(i*gridSize,0); ctx.lineTo(i*gridSize,canvas.height); ctx.stroke(); }
    for (let i=0;i<=gridHeight;i++){ ctx.beginPath(); ctx.moveTo(0,i*gridSize); ctx.lineTo(canvas.width,i*gridSize); ctx.stroke(); }

    // snake
    snake.forEach((segment, idx)=>{
        ctx.fillStyle = idx===0 ? '#00e676' : '#00bcd4';
        ctx.fillRect(segment.x*gridSize, segment.y*gridSize, gridSize, gridSize);
        ctx.strokeStyle = '#000'; ctx.strokeRect(segment.x*gridSize, segment.y*gridSize, gridSize, gridSize);
    });

    // apple via image
    if (apple.isEK) {
      if (appleImgEK.complete) {
        ctx.drawImage(appleImgEK, apple.x * gridSize, apple.y * gridSize, gridSize, gridSize);
      } else {
        // fallback circle until image loads
        ctx.fillStyle = '#ffd54f';
        ctx.beginPath();
        ctx.arc(apple.x*gridSize + gridSize/2, apple.y*gridSize + gridSize/2, gridSize/2 - 2, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#000'; ctx.font='bold 10px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('EK', apple.x*gridSize + gridSize/2, apple.y*gridSize + gridSize/2);
      }
    } else {
      if (appleImg.complete) {
        ctx.drawImage(appleImg, apple.x * gridSize, apple.y * gridSize, gridSize, gridSize);
      } else {
        // fallback circle until image loads
        ctx.fillStyle = '#ff9800';
        ctx.beginPath();
        ctx.arc(apple.x*gridSize + gridSize/2, apple.y*gridSize + gridSize/2, gridSize/2 - 2, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#000'; ctx.font='bold 10px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('KSPT', apple.x*gridSize + gridSize/2, apple.y*gridSize + gridSize/2);
      }
    }

    // floating texts
    for (let i=floatingTexts.length-1;i>=0;i--){
        const f = floatingTexts[i];
        ctx.globalAlpha = f.alpha;
        ctx.fillStyle = f.color;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(f.text, f.x, f.y - f.rise);
        f.rise += 0.6;
        f.alpha -= 0.03;
        if (f.alpha <= 0) floatingTexts.splice(i,1);
    }
    ctx.globalAlpha = 1;
}

function handleJoystickMove(clientX, clientY, startX, startY) {
  const deltaX = clientX - startX;
  const deltaY = clientY - startY;

  if (Math.abs(deltaX) > Math.abs(deltaY)) {
    if (deltaX > 20 && direction.x !== -1) direction = { x: 1, y: 0 };
    else if (deltaX < -20 && direction.x !== 1) direction = { x: -1, y: 0 };
  } else {
    if (deltaY > 20 && direction.y !== -1) direction = { x: 0, y: 1 };
    else if (deltaY < -20 && direction.y !== 1) direction = { x: 0, y: -1 };
  }
}

function moveKnob(clientX, clientY, startX, startY, knob, maxRadius) {
  let dx = clientX - startX;
  let dy = clientY - startY;

  const dist = Math.hypot(dx, dy);
  if (dist > maxRadius) {
    dx = (dx / dist) * maxRadius;
    dy = (dy / dist) * maxRadius;
  }

  knob.style.transform =
    `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
}

/* UI */
function updateUI(){
    scoreEl.textContent = score;
    lengthEl.textContent = snakeLength;
    speedEl.textContent = Math.round((50/moveInterval) * 50) + '%';
}

// –∑–∞—â–∏—Ç–∞ –æ—Ç –¥–≤–æ–π–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç–æ–∫
let __kspt_gameOverHandled = false;

function gameOver() {
  if (__kspt_gameOverHandled) return;
  __kspt_gameOverHandled = true;

  gameRunning = false;

  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é / —Ü–∏–∫–ª—ã
  try { if (animationId) cancelAnimationFrame(animationId); animationId = null; } catch(e){}
  try { if (window.__kspt_game_updater) { clearInterval(window.__kspt_game_updater); window.__kspt_game_updater = null; } } catch(e){}
  try { if (window.__kspt_hourly_updater) { clearInterval(window.__kspt_hourly_updater); window.__kspt_hourly_updater = null; } } catch(e){}

  // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—É—é —Å—É–º–º—É (–µ—Å–ª–∏ –≤—ã–¥–∞–≤–∞–ª–∏ –Ω–∞–≥—Ä–∞–¥—ã –≤–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã)
  const earned = (window.__kspt_earnedKSPT && Number(window.__kspt_earnedKSPT)) ? Number(window.__kspt_earnedKSPT) : 0;
  earnedKSPTEl.textContent = earned.toFixed(2);

  finalScoreEl.textContent = score;
  finalLengthEl.textContent = snakeLength;

  // EK (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å sessionEK)
  if (typeof sessionEK !== 'undefined' && earnedEKElem) {
    earnedEKElem.textContent = sessionEK;
  }

  document.getElementById('gameOverScreen').style.display = 'block';
}

/* loop rAF + accumulator */
function gameLoop(ts){
    if (!lastTimestamp) lastTimestamp = ts;
    const dt = ts - lastTimestamp;
    lastTimestamp = ts;

    if (!gamePaused && gameRunning) {
        accumulator += dt;

        while (accumulator >= moveInterval) {
            step();
            accumulator -= moveInterval;
        }
    } else {
        // ‚≠ê –í–ê–ñ–ù–û ‚Äî —á–∏—Å—Ç–∏–º –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è
        accumulator = 0;
    }

    draw();
    animationId = requestAnimationFrame(gameLoop);
}

/* controls */
function restartGame(){

__kspt_gameOverHandled = false;
window.__kspt_earnedKSPT = 0;
sessionEK = 0;

    snake = [{x:6,y:6},{x:5,y:6},{x:4,y:6}];
    direction = {x:1,y:0};
    do {
      apple = {x: Math.floor(Math.random()*gridWidth), y: Math.floor(Math.random()*gridHeight)};
      // —à–∞–Ω—Å 3% —á—Ç–æ —ç—Ç–æ EK-—è–±–ª–æ–∫–æ
      apple.isEK = Math.random() < 0.03;
    } while (snake.some(s => s.x === apple.x && s.y === apple.y));
    score = 0;
    snakeLength = 3;
    moveInterval = 100;
    gameRunning = true;
    gamePaused = false;
    sessionEK = 0;
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('pauseBtn').textContent = 'Pause';
    updateUI();
    if (animationId) cancelAnimationFrame(animationId);
    lastTimestamp = 0;
    accumulator = 0;
    animationId = requestAnimationFrame(gameLoop);
}

function exitGame() {
  try {
    if (typeof HOST !== 'undefined' && HOST && typeof HOST.exitGame === 'function') {
      HOST.exitGame();
      return;
    }
  } catch (e) {
    console.warn('HOST.exitGame direct call failed', e);
  }

  try {
    (window.top || window.parent || window).postMessage({ type: 'kspt_exit_game' }, '*');
    return;
  } catch (e) {
    console.warn('postMessage exit failed', e);
  }

  // Fallback
  alert('Exit (no parent handler)');
}

/* joystick & keyboard */
function setupJoystick() {
  const joystick = document.getElementById('joystickArea');
  const knob = joystick.querySelector('.joystick-center');
  const maxRadius = 45;

  let isActive = false;
  let startX = 0;
  let startY = 0;

  function resetKnob() {
    knob.style.transition = 'transform 0.15s ease';
    knob.style.transform = 'translate(-50%, -50%)';
    setTimeout(() => knob.style.transition = '', 150);
  }

  function processMove(clientX, clientY) {
    moveKnob(clientX, clientY, startX, startY, knob, maxRadius);
    handleJoystickMove(clientX, clientY, startX, startY);
  }

  /* ===== TOUCH ===== */
  joystick.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    startX = t.clientX;
    startY = t.clientY;
    isActive = true;
    canVibrate = true;
  });

  joystick.addEventListener('touchmove', (e) => {
    if (!isActive) return;
    const t = e.touches[0];
    processMove(t.clientX, t.clientY);
  });

  joystick.addEventListener('touchend', () => {
    isActive = false;
    resetKnob();
  });

  /* ===== MOUSE ===== */
  joystick.addEventListener('mousedown', (e) => {
    e.preventDefault();
    startX = e.clientX;
    startY = e.clientY;
    isActive = true;
    canVibrate = true;
  });

  window.addEventListener('mousemove', (e) => {
    if (!isActive) return;
    processMove(e.clientX, e.clientY);
  });

  window.addEventListener('mouseup', () => {
    if (!isActive) return;
    isActive = false;
    resetKnob();
  });
}

document.addEventListener('keydown', (e)=>{
    canVibrate = true;
    if (e.key === 'ArrowUp' && direction.y !== 1) direction = {x:0,y:-1};
    if (e.key === 'ArrowDown' && direction.y !== -1) direction = {x:0,y:1};
    if (e.key === 'ArrowLeft' && direction.x !== 1) direction = {x:-1,y:0};
    if (e.key === 'ArrowRight' && direction.x !== -1) direction = {x:1,y:0};
    if (e.key === ' ') togglePause();
    if ((e.key === 'ArrowUp' || e.key === 'w') && direction.y !== 1) direction = {x:0,y:-1};
if ((e.key === 'ArrowDown' || e.key === 's') && direction.y !== -1) direction = {x:0,y:1};
if ((e.key === 'ArrowLeft' || e.key === 'a') && direction.x !== 1) direction = {x:-1,y:0};
if ((e.key === 'ArrowRight' || e.key === 'd') && direction.x !== -1) direction = {x:1,y:0};
});

/* events */
document.getElementById('pauseBtn').addEventListener('click', ()=>{ canVibrate = true; togglePause(); });
document.getElementById('restartBtn').addEventListener('click', ()=>{ 
  canVibrate = true;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∏–ª–µ—Ç—ã –ª–æ–∫–∞–ª—å–Ω–æ
  if (!ensureHasTicketOrWarn()) return;
  
  // –ü—Ä–æ—Å–∏–º —Ä–æ–¥–∏—Ç–µ–ª—è –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —Ä–∞—É–Ω–¥ (–æ–Ω —Å–∞–º —Å–ø–∏—à–µ—Ç –±–∏–ª–µ—Ç –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
  try {
    (window.parent || window.top).postMessage({ 
      type: 'kspt_new_round'
    }, '*');
  } catch(e) {
    console.warn('Failed to send new round message', e);
  }
  
  // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É
  restartGame();
});

document.getElementById('exitBtn').addEventListener('click', exitGame);
document.getElementById('exitToMenuBtn').addEventListener('click', exitGame);
document.getElementById('playAgainBtn').addEventListener('click', () => {
    try {
        (window.parent || window.top).postMessage({ type: 'kspt_new_round' }, '*');
    } catch(e){}
    restartGame();
});

/* init */
function initGame(){
    setupJoystick();
    updateUI();
    lastTimestamp = 0;
    accumulator = 0;
    sessionEK = 0;
    if (animationId) cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame(gameLoop);
}

window.addEventListener('load', initGame);
</script>
</body>
</html>