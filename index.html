<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>KSPT Token</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<script src="https://telegram.org/js/telegram-web-app.js"></script>

<style>
*{box-sizing:border-box}
body{
  margin:0;
  background-color:#0b0b0b;
  background-size: cover;
  background-position: center;
  background-attachment: fixed;
  background-repeat: no-repeat;
  font-family:Arial,sans-serif;
  color:#fff;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation; 
  user-select: none;
  transition: background-image 0.5s ease;
  padding-bottom: 80px; /* Space for Global Nav */
}

.app{
  max-width:420px;
  margin:0 auto;
  min-height:100vh;
  display:flex;
  flex-direction:column;
  padding:16px;
  position: relative;
  z-index: 1; /* Ensure app content is above body bg */
}

/* ===== COMMON ===== */
.screen{display:none}
.screen.active{display:block; animation: fadeIn 0.2s ease;}

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

.top-bar{
  display:flex;
  align-items:center;
  gap:10px;
  margin-bottom:16px;
}
.top-bar img{
  width:32px;
  height:32px;
}
.top-bar span{
  font-size:16px;
  opacity:.85;
}

/* Close Button Style */
.close-x {
  width: 24px !important;
  height: 24px !important;
  cursor: pointer;
  margin-left: auto;
  opacity: 0.7;
}

.balance-main{
  font-size:22px;
  margin:10px 0 5px; 
  text-align:center;
}

.offline-info {
  text-align: center;
  font-size: 14px;
  color: #aaa;
  margin-bottom: 25px;
}

/* ===== COIN ===== */
.coin{
  width:220px;
  height:220px;
  margin:0 auto 40px;
  display:block;
  transition:transform .08s ease;
  cursor: pointer;
  position: relative;
  z-index: 10;
}

.coin.anim {
  transform: scale(0.92);
}

/* Tap Feedback Animation Style */
.tap-text {
  position: absolute;
  color: #fff;
  font-weight: bold;
  font-size: 24px;
  pointer-events: none;
  text-shadow: 0 0 3px #000;
  animation: floatUp 0.5s ease-out forwards;
  z-index: 9999;
}

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
}

/* ===== BOTTOM BUTTONS ===== */
.bottom-bar{
  margin-top:auto;
  display:flex;
  flex-direction: column;
  gap:10px;
}

.button-row {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.long-btn{
  flex:1;
  height:70px;
  background:#1a1a1a;
  border-radius:22px;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor: pointer;
}
.long-btn img{
  height:42px;
  width:auto;
}

/* Settings Button Style */
.settings-row {
  display: flex;
  justify-content: flex-end;
}
.settings-btn {
  width: 60px;
  height: 60px;
  background: #1a1a1a;
  border-radius: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
.settings-btn img {
  width: 30px;
  height: 30px;
}

/* ===== CARDS ===== */
.card{
  background:#161616;
  border-radius:18px;
  padding:14px;
  margin-bottom:14px;
  overflow: hidden;
}

.card-title{font-weight:bold;margin-bottom:6px}
.card-sub{font-size:13px;opacity:.6;margin-bottom:8px}

.card-img {
  width: 100px;
  height: 80px;
  float: right;
  margin-top: 0; 
  margin-left: 10px;
  border-radius: 8px;
  object-fit: contain;
  background: rgba(255,255,255,0.03);
}

.card-lvl {
  font-size: 12px;
  color: #ff9800;
  margin-bottom: 4px;
}

button{
  width:100%;
  padding:12px;
  border:none;
  border-radius:12px;
  background:#262626;
  color:#fff;
  font-size:15px;
  cursor: pointer;
}

button.active{background:#2e7d32}
button.owned{background:#333;opacity:.6}

.back{
  margin-top:20px;
  opacity:.6;
  background:none;
}

/* ===== BET ===== */
.input-group {
  display: flex;
  gap: 10px;
  margin-bottom: 8px;
}

input{
  width:100%;
  padding:12px;
  border-radius:12px;
  border:none;
  font-size:16px;
  background: #fff;
  color: #000;
}

.max-btn {
  width: auto;
  padding: 0 20px;
  background: #ff9800;
  font-weight: bold;
}

.confirm{
  background:#2e7d32;
  margin-top:8px;
}
.cancel{
  background:#444;
  margin-top:6px;
}

/* ===== NEW FEATURES STYLES ===== */

.energy-box {
  position: absolute;
  bottom: 180px;
  left: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: bold;
  font-size: 14px;
  background: rgba(0,0,0,0.5);
  padding: 5px 10px;
  border-radius: 20px;
  pointer-events: none;
}
.energy-box img {
  width: 20px;
  height: 20px;
}

.promo-box {
  margin-top: 20px;
  padding-top: 10px;
  border-top: 1px solid #333;
}
.promo-input-group {
  display: flex;
  gap: 8px;
}
.promo-input-group input {
  flex: 1;
}
.promo-btn {
  width: auto;
  background: #ff9800;
  color: #000;
  font-weight: bold;
}

.red-screen {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: red;
  z-index: 9999;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: white;
  text-align: center;
}
.red-screen h1 {
  font-size: 40px;
  margin: 0;
}

/* Settings Styles */
.bg-preview {
  width: 100%;
  height: 100px;
  background-size: cover;
  background-position: center;
  border-radius: 12px;
  margin-bottom: 10px;
  border: 2px solid #333;
}
.bg-preview.selected {
  border-color: #2e7d32;
}

/* Unban Input Styles */
.unban-group {
  margin-top: 30px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center;
}
.unban-group input {
  width: 200px;
  text-align: center;
}
.unban-group button {
  width: auto;
  padding: 10px 20px;
  background: #333;
  color: #fff;
}

/* Custom Warning Modal */
.warning-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0 right: 0; bottom: 0;
  background: rgba(0,0,0,0.9);
  z-index: 10000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #fff;
  text-align: center;
  padding: 20px;
}
.warning-btn-small {
  width: 50px;
  height: 30px;
  padding: 0;
  margin-top: 25px;
  font-size: 11px;
  background: #444;
  border: 1px solid #666;
}

/* Toast Notification */
.toast {
  position: fixed;
  top: 15%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.6);
  padding: 10px 20px;
  border-radius: 20px;
  color: #fff;
  font-size: 14px;
  font-weight: bold;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s ease;
  z-index: 11000;
}
.toast.show {
  opacity: 1;
}

/* ===== PUZZLE & CAPSULE STYLES ===== */
.puzzle-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;
}

.puzzle-grid {
    display: grid;
    grid-template-columns: repeat(3, 80px);
    grid-template-rows: repeat(3, 80px);
    gap: 2px;
    background: #333;
    padding: 2px;
    border-radius: 4px;
    position: relative;
}

.puzzle-cell {
    width: 80px;
    height: 80px;
    background: #111;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.puzzle-cell img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: none;
    /* Hidden by default until placed */
}

.puzzle-cell.filled img {
    display: block;
}

.puzzle-full-img {
    width: 246px; /* 3*80 + gaps */
    height: 246px;
    object-fit: cover;
    display: none;
    position: absolute;
    top: 2px;
    left: 2px;
    z-index: 5;
    animation: fadeIn 1s forwards;
}

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

.puzzle-controls {
    margin-top: 15px;
    width: 100%;
    text-align: center;
}

.capsule-info {
    text-align: center;
    margin-top: 30px;
    padding: 20px;
    background: #1a1a1a;
    border-radius: 18px;
}

.capsule-img-small {
    width: 80px;
    height: auto;
    margin-bottom: 10px;
}

/* Capsule Breaking Modal */
.capsule-modal {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.85);
    z-index: 12000;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: background-color 0.5s;
}

.capsule-modal.active {
    display: flex;
}

.capsule-center {
    width: 180px;
    height: auto;
    transition: transform 0.1s;
    cursor: pointer;
}

.capsule-center.zoomed {
    transform: scale(1.5);
    transition: transform 1s ease-in-out;
}

.white-fade {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: white;
    opacity: 0;
    pointer-events: none;
    z-index: 13000;
    transition: opacity 3s ease-in-out;
}

.white-fade.active {
    opacity: 1;
}

.reward-popup {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #222;
    padding: 30px;
    border-radius: 20px;
    border: 2px solid #ff9800;
    text-align: center;
    z-index: 14000;
    width: 80%;
    max-width: 300px;
    box-shadow: 0 0 50px rgba(0,0,0,0.8);
}
.reward-img {
    width: 100px;
    height: 100px;
    object-fit: contain;
    margin-bottom: 15px;
}

/* ===== MARKET STYLES ===== */
.global-nav {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 65px;
  background: #111;
  border-top: 1px solid #333;
  display: flex;
  justify-content: space-around;
  align-items: center;
  z-index: 9000;
  padding-bottom: 10px;
  /* Safe area */
}

.nav-item {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #666;
  font-size: 11px;
  cursor: pointer;
}
.nav-item.active {
  color: #ff9800;
}
.nav-icon {
  width: 24px;
  height: 24px;
  margin-bottom: 4px;
  background-color: #444;
  /* Fallback */
  border-radius: 50%;
}
.nav-item.active .nav-icon {
  background-color: #ff9800;
}

/* Market Specifics */
.market-intro {
  text-align: center;
  margin-top: 50px;
}
.market-intro h1 {
  color: #ff9800;
  font-size: 28px;
}
.market-list-item {
  display: flex;
  align-items: center;
  background: #1a1a1a;
  padding: 12px;
  border-radius: 12px;
  margin-bottom: 10px;
  cursor: pointer;
  border: 1px solid transparent;
}
.market-list-item:active {
  background: #222;
}
.token-icon {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  margin-right: 12px;
}
.token-info {
  flex: 1;
}
.token-name { font-weight: bold;
font-size: 16px; }
.token-price { font-size: 14px; color: #aaa; }
.price-up { color: #2e7d32; }
.price-down { color: #d32f2f;
}

/* Chart */
.chart-container {
  width: 100%;
  height: 150px;
  background: #111;
  border: 1px solid #333;
  border-radius: 12px;
  position: relative;
  margin-bottom: 15px;
  overflow: hidden;
}
.chart-canvas {
  width: 100%;
  height: 100%;
}
.price-tooltip {
  position: absolute;
  background: rgba(0,0,0,0.8);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  pointer-events: none;
  display: none;
}

/* Account Section */
.account-box {
  background: #161616;
  padding: 15px;
  border-radius: 16px;
  margin-bottom: 20px;
  border: 1px solid #333;
}
.acc-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 10px;
}
.acc-name { font-size: 18px; font-weight: bold; color: #ff9800; }
.acc-desc { font-size: 12px; color: #888; margin-top: 4px;
}
.acc-edit-btn {
  font-size: 11px;
  padding: 4px 8px;
  background: #333;
  width: auto;
}
.portfolio-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-top: 1px solid #222;
  font-size: 13px;
}

/* Custom Keyboard Styles */
.custom-keyboard {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: #222;
  padding: 10px;
  border-top: 1px solid #444;
  z-index: 20000;
}

.custom-keyboard.active {
  display: block;
}

.keyboard-row {
  display: flex;
  justify-content: center;
  gap: 5px;
  margin-bottom: 5px;
}

.keyboard-key {
  flex: 1;
  height: 50px;
  background: #333;
  border: none;
  border-radius: 5px;
  color: white;
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.keyboard-key.wide {
  flex: 2;
}

.keyboard-key.done {
  background: #2e7d32;
}

.keyboard-key.backspace {
  background: #d32f2f;
}

/* Image Cropping Modal */
.crop-modal {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.9);
  z-index: 15000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.crop-modal.active {
  display: flex;
}

.crop-container {
  width: 300px;
  height: 300px;
  position: relative;
  overflow: hidden;
  border: 2px solid white;
  border-radius: 50%;
  margin-bottom: 20px;
}

.crop-image {
  position: absolute;
  top: 0;
  left: 0;
  max-width: none;
  cursor: move;
}

.crop-circle {
  position: absolute;
  position: absolute;
  top: 50%;
  left: 50%;
  width: 200px;
  height: 200px;
  transform: translate(-50%, -50%);
  border: 2px dashed #ff9800;
  border-radius: 50%;
  pointer-events: none;
  z-index: 2;
}

.crop-controls {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

.crop-zoom {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
  color: white;
}

.crop-zoom input {
  width: 200px;
}
</style>
</head>

<body>

<div id="toast" class="toast">Purchase successful</div>
<div id="whiteFade" class="white-fade"></div>

<div id="rewardPopup" class="reward-popup">
    <h2 style="color:#ff9800; margin-top:0;">REWARD!</h2>
    <img id="rewardImg" class="reward-img" src="" alt="Reward">
    <div id="rewardText" style="margin-bottom:20px; font-size:18px;"></div>
    <button onclick="closeReward()">Collect</button>
</div>

<div id="capsuleBreakModal" class="capsule-modal">
    <div id="capsuleHint" style="margin-bottom:20px; font-size:24px; font-weight:bold;">Tap to open!</div>
    <img id="capsuleBreakImg" src="capsule.png" class="capsule-center">
</div>

<div id="cheatWarningModal" class="warning-modal">
  <h2 style="color:red; font-size: 32px; margin-bottom: 10px;">STOP!</h2>
  <p style="font-size: 18px;">You are tapping too fast.</p>
  <p style="font-size: 14px; opacity: 0.7;">Continued fast tapping will reset your progress.</p>
  <button class="warning-btn-small" onclick="dismissWarning()">OK</button>
</div>

<div id="redScreen" class="red-screen">
  <h1>DONT CHEAT!!</h1>
  <div class="unban-group">
    <input type="text" id="unbanInput" placeholder="Enter Unban Key">
    <button onclick="attemptUnban()">Unlock</button>
  </div>
</div>

<!-- Custom Keyboard -->
<div id="customKeyboard" class="custom-keyboard">
  <div class="keyboard-row">
    <button class="keyboard-key" data-key="1">1</button>
    <button class="keyboard-key" data-key="2">2</button>
    <button class="keyboard-key" data-key="3">3</button>
    <button class="keyboard-key" data-key="backspace">⌫</button>
  </div>
  <div class="keyboard-row">
    <button class="keyboard-key" data-key="4">4</button>
    <button class="keyboard-key" data-key="5">5</button>
    <button class="keyboard-key" data-key="6">6</button>
    <button class="keyboard-key" data-key=".">.</button>
  </div>
  <div class="keyboard-row">
    <button class="keyboard-key" data-key="7">7</button>
    <button class="keyboard-key" data-key="8">8</button>
    <button class="keyboard-key" data-key="9">9</button>
    <button class="keyboard-key" data-key="0">0</button>
  </div>
  <div class="keyboard-row">
    <button class="keyboard-key wide" data-key="done">DONE</button>
  </div>
</div>

<!-- Image Cropping Modal -->
<div id="cropModal" class="crop-modal">
  <div style="color: white; font-size: 20px; margin-bottom: 20px;">Crop Your Image</div>
  <div class="crop-container">
    <img id="cropImage" class="crop-image" src="" alt="Crop Image">
    <div class="crop-circle"></div>
  </div>
  <div class="crop-zoom">
    <span>Zoom:</span>
    <input id="cropZoom" type="range" min="100" max="400" value="100">
  </div>
  <div class="crop-controls">
    <button onclick="cancelCrop()" style="background: #d32f2f;">Cancel</button>
    <button onclick="applyCrop()" style="background: #2e7d32;">Apply Crop</button>
  </div>
</div>

<div class="app">

<div id="main" class="screen active">
  <div class="balance-main" id="balanceMain">0.00 KSPT</div>
  <div class="offline-info" id="offlineRateMain">Offline: 0.00 KSPT/h</div>

  <img id="coin" class="coin" src="kspt.png" alt="Coin">
  
  <div class="energy-box">
    <img src="ener.png" alt="E">
    <span id="energyDisplay">2500 / 2500</span>
  </div>
  
  <div class="bottom-bar">
    <div class="button-row">
      <div class="long-btn" onclick="openScreen('skins')">
        <img src="m.png" alt="Skins">
      </div>
      <div class="long-btn" onclick="openScreen('offlineShop')">
        <img src="k.png" alt="Mining">
      </div>
    </div>
    <div class="button-row">
      <div class="long-btn" onclick="openScreen('tech')">
         <img src="t.png" alt="Tech">
      </div>
      <div class="long-btn" onclick="openScreen('capsuleScreen')">
         <img src="puz.png" alt="Capsule">
      </div>
    </div>
    <div class="settings-row">
       <div class="settings-btn" onclick="openScreen('settings')">
          <img src="settings.png" alt="Settings">
       </div>
    </div>
  </div>
</div>

<div id="market" class="screen">
  <div id="marketContainer"></div>
</div>

<div id="capsuleScreen" class="screen">
  <div class="top-bar">
    <img src="kspt.png">
    <span id="balanceCapsule"></span>
    <img src="iks.png" class="close-x" onclick="openScreen('main')">
  </div>

  <div class="card">
    <div class="card-title">Ancient Puzzle</div>
    <div class="card-sub">Collect all 9 pieces to unlock Hamster Piece Skin!</div>
    
    <div class="puzzle-container">
        <div class="puzzle-grid">
           <img src="pazl.png" id="puzzleFull" class="puzzle-full-img">
           <div class="puzzle-cell" id="pz1"><img src="pazl1.png"></div>
            <div class="puzzle-cell" id="pz2"><img src="pazl2.png"></div>
            <div class="puzzle-cell" id="pz3"><img src="pazl3.png"></div>
            <div class="puzzle-cell" id="pz4"><img src="pazl4.png"></div>
            <div class="puzzle-cell" id="pz5"><img src="pazl5.png"></div>
            <div class="puzzle-cell" id="pz6"><img src="pazl6.png"></div>
            <div class="puzzle-cell" id="pz7"><img src="pazl7.png"></div>
            <div class="puzzle-cell" id="pz8"><img src="pazl8.png"></div>
            <div class="puzzle-cell" id="pz9"><img src="pazl9.png"></div>
        </div>
        <div class="puzzle-controls">
            <div id="puzzleStatus" class="card-sub" style="margin-bottom:10px;">Owned: 0/9</div>
            <button id="btnPlacePiece" onclick="placePuzzlePieces()" style="display:none;">Place Available Pieces</button>
             <div id="puzzleCompletedText" style="display:none; color:#ff9800; font-weight:bold; margin-top:10px;">A new puzzle will appear soon!</div>
        </div>
    </div>
  </div>

  <div class="card capsule-info">
    <img src="capsule.png" class="capsule-img-small">
    <div class="card-title">Mystery Capsule</div>
    <div class="card-sub" id="capsuleTimer">Ready to open!</div>
    <button id="btnOpenCapsule" onclick="startCapsuleSequence()" style="background:#ff9800; color:#000; font-weight:bold; margin-top:10px;">OPEN!</button>
  </div>

  <button class="back" onclick="openScreen('main')">Back</button>
</div>

<div id="settings" class="screen">
  <div class="top-bar">
    <img src="kspt.png">
    <span id="balanceSettings"></span>
    <img src="iks.png" class="close-x" onclick="openScreen('main')">
  </div>

  <div id="settings-main">
    <div class="card">
      <div class="card-title">Settings</div>
      <div class="card-sub">Choose a category</div>
      <button onclick="showSettingsSub('sound')" style="margin-bottom:10px;">Vibration & Sound</button>
      <button onclick="showSettingsSub('bg')">Backgrounds</button>
    </div>
    <button class="back" onclick="openScreen('main')">Back</button>
  </div>

  <div id="settings-sound" style="display:none;">
    <div class="card">
        <div class="card-title">Vibration</div>
        <div class="card-sub">Haptic Feedback</div>
        <div class="button-row">
            <button id="vib-off" onclick="setVibration('off')" style="width:23%; padding:8px; font-size:12px;">Off</button>
            <button id="vib-low" onclick="setVibration('low')" style="width:23%; padding:8px; font-size:12px;">Low</button>
            <button id="vib-med" onclick="setVibration('medium')" style="width:23%; padding:8px; font-size:12px;">Med</button>
            <button id="vib-str" onclick="setVibration('strong')" style="width:23%; padding:8px; font-size:12px;">Strong</button>
        </div>
    </div>

    <div class="card">
        <div class="card-title">Music</div>
        <div class="card-sub">Game Soundtrack</div>
        <button id="music-stop" onclick="stopMusic()" style="margin-bottom:10px; background:#444;">Disable Music</button>
        
        <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px; border-top:1px solid #333; padding-top:10px;">
            <img src="mistic.png" style="width:30px; height:30px; border-radius:5px;">
            <div style="flex:1;">
                <div style="font-weight:bold; font-size:14px;">Mystic Wild West</div>
                <div style="font-size:11px; opacity:0.6;">Default</div>
            </div>
            <button onclick="previewMusic('mistic')" style="width:auto; padding:5px 10px; font-size:11px; margin-right:5px;">Play 15s</button>
            <button id="btn-music-mistic" onclick="setMusic('mistic')" style="width:auto; padding:5px 10px; font-size:11px;">Select</button>
        </div>

        <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px; border-top:1px solid #333; padding-top:10px;">
            <img src="gabber.png" style="width:30px; height:30px; border-radius:5px;">
            <div style="flex:1;">
                <div style="font-weight:bold; font-size:14px;">Victory Europop</div>
                <div style="font-size:11px; opacity:0.6;">Price: 210 KSPT</div>
            </div>
             <button onclick="previewMusic('gabber')" style="width:auto; padding:5px 10px; font-size:11px; margin-right:5px;">Play 15s</button>
            <button id="btn-music-gabber" onclick="buyMusic('gabber', 210)" style="width:auto; padding:5px 10px; font-size:11px;">Buy</button>
        </div>

        <div id="music-onion-row" style="display:flex; align-items:center; gap:10px; margin-bottom:10px; border-top:1px solid #333; padding-top:10px; display:none;">
            <img src="onion.png" style="width:30px; height:30px; border-radius:5px;">
             <div style="flex:1;">
                <div style="font-weight:bold; font-size:14px;">Funny Onion Song</div>
                <div style="font-size:11px; opacity:0.6;">Exclusive</div>
            </div>
             <button onclick="previewMusic('onion')" style="width:auto; padding:5px 10px; font-size:11px; margin-right:5px;">Play 15s</button>
            <button id="btn-music-onion" onclick="setMusic('onion')" style="width:auto; padding:5px 10px; font-size:11px;">Select</button>
        </div>
        
        <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px; border-top:1px solid #333; padding-top:10px;">
            <img src="calm.png" style="width:30px; height:30px; border-radius:5px;">
             <div style="flex:1;">
                <div style="font-weight:bold; font-size:14px;">Calm + Hush</div>
                <div style="font-size:11px; opacity:0.6;">Capsule Exclusive</div>
            </div>
             <button onclick="previewMusic('calm')" style="width:auto; padding:5px 10px; font-size:11px; margin-right:5px;">Play 15s</button>
            <button id="btn-music-calm" onclick="setMusic('calm')" style="width:auto; padding:5px 10px; font-size:11px;">Locked</button>
        </div>

    </div>
    <button class="back" onclick="showSettingsSub('main')">Back</button>
  </div>

  <div id="settings-bg" style="display:none;">
      <div class="card">
        <div class="card-title">Backgrounds</div>
        <div class="card-sub">Customize your main menu</div>
      </div>

      <div class="card">
        <div class="bg-preview" style="background-color: #0b0b0b;"></div>
        <div class="card-title">Default Dark</div>
        <div class="card-sub">Classic KSPT style</div>
        <button id="bg-btn-default" onclick="equipBackground('default')">Selected</button>
      </div>

      <div class="card">
        <div class="bg-preview" style="background-image: url('forest.png');"></div>
        <div class="card-title">Forest Vibe</div>
        <div class="card-sub">Nature look</div>
        <button id="bg-btn-forest" onclick="buyBackground('forest', 320)">Buy 320 KSPT</button>
      </div>

      <div class="card">
        <div class="bg-preview" style="background-image: url('star.png');"></div>
        <div class="card-title">Space View</div>
        <div class="card-sub">Included in Space Edition Skin</div>
        <button id="bg-btn-space" onclick="equipBackground('space')">Locked (Buy Space Skin)</button>
      </div>

      <div class="card">
        <div class="bg-preview" style="background-image: url('heaven.png');"></div>
        <div class="card-title">Heaven</div>
        <div class="card-sub">Rare Capsule Drop</div>
        <button id="bg-btn-heaven" onclick="equipBackground('heaven')">Locked</button>
      </div>

      <div class="card">
        <div class="bg-preview" style="background-image: url('ric.png'); border: 2px solid gold;"></div>
        <div class="card-title" style="color: gold;">KSPT: Rich Edition</div>
        <div class="card-sub">For the elite</div>
        <button id="bg-btn-ric" onclick="buyBackground('ric', 5120)">Buy 5120 KSPT</button>
      </div>
      
      <div class="card">
        <div class="bg-preview" style="background-image: url('bug.png');"></div>
        <div class="card-title">Dead Pixel</div>
        <div class="card-sub">Bonus with Pixel Coin Skin</div>
       <button id="bg-btn-bug" onclick="equipBackground('bug')">Locked</button>
      </div>
      
      <button class="back" onclick="showSettingsSub('main')">Back</button>
  </div>
</div>

<div id="skins" class="screen">
  <div class="top-bar">
    <img src="kspt.png">
    <span id="balanceSkins"></span>
    <img src="iks.png" class="close-x" onclick="openScreen('main')">
  </div>

  <div class="card">
    <div class="card-title">Default Coin</div>
    <div class="card-sub">Standard (+0 KSPT/h)</div>
    <button id="skin-default" onclick="buySkin('default',0)"></button>
  </div>

  <div class="card">
    <div class="card-title">WHAT IS KSPT</div>
    <div class="card-sub">Price: 1 KSPT (+1 KSPT/h)</div>
  <button id="skin-what" onclick="buySkin('what',1)"></button>
  </div>

  <div class="card">
    <img id="skin-img-burger" src="knowdont.png" class="card-img">
    <div class="card-title">KSPT Burger Edition</div>
    <div class="card-sub">Price: 10 KSPT (+2.2 KSPT/h)</div>
    <button id="skin-burger" onclick="buySkin('burger',10)"></button>
  </div>

  <div class="card">
    <img id="skin-img-joost" src="knowdont.png" class="card-img">
    <div class="card-title">Little Aqua</div>
    <div class="card-sub">Price: 30 KSPT (+4 KSPT/h)</div>
    <button id="skin-joost" onclick="buySkin('joost',30)"></button>
  </div>

  <div class="card">
    <img id="skin-img-dog" src="knowdont.png" class="card-img">
    <div class="card-title">Dogs World</div>
    <div class="card-sub">Price: 80 KSPT (+6.7 KSPT/h)</div>
    <button id="skin-dog" onclick="buySkin('dog',80)"></button>
  </div>

  <div class="card">
    <img id="skin-img-diam" src="knowdont.png" class="card-img">
    <div class="card-title">Cringe Diamond</div>
    <div class="card-sub">Price: 100 KSPT (+10 KSPT/h)</div>
    <button id="skin-diam" onclick="buySkin('diam',100)"></button>
  </div>
  
  <div class="card">
    <img id="skin-img-tung" src="knowdont.png" class="card-img">
    <div class="card-title">Meme-Brain</div>
    <div class="card-sub">Skin + animation</div> <div class="card-sub">Price: 240 KSPT (+15 KSPT/h)</div>
    <button id="skin-tung" onclick="buySkin('tung',240)">BUY 240 KSPT</button>
  </div>

  <div class="card">
    <img id="skin-img-euro" src="knowdont.png" class="card-img">
    <div class="card-title">Euro Coin</div>
    <div class="card-sub">Skin + additional skin</div>
    <div class="card-sub">Price: 780 KSPT (+27 KSPT/h)</div>
    <button id="skin-euro" onclick="buySkin('euro',780)">BUY 780 KSPT</button>
  </div>

  <div class="card">
    <img id="skin-img-space" src="knowdont.png" class="card-img">
    <div class="card-title">KSPT: Space Edition</div>
    <div class="card-sub">Skin + animation + background</div>
    <div class="card-sub">Price: 1210 KSPT (+40 KSPT/h)</div> 
    <button id="skin-space" onclick="buySkin('space',1210)">BUY 1210 KSPT</button>
  </div>
  
  <div class="card">
    <img id="skin-img-pixe" src="knowdont.png" class="card-img">
    <div class="card-title">Pixel Coin</div>
    <div class="card-sub">Toggle animation + visual style</div>
    <div class="card-sub">Price: 3,215 KSPT (+88 KSPT/h)</div>
    <button id="skin-pixe" onclick="buySkin('pixe',3215)">BUY 3,215 KSPT</button>
  </div>

  <div class="card">
    <img id="skin-img-onion" src="knowdont.png" class="card-img">
    <div class="card-title">Funny Onion</div>
    <div class="card-sub">Most expensive skin + animation</div>
    <div class="card-sub">Price: 10,110 KSPT (+120 KSPT/h)</div>
    <button id="skin-onion" onclick="buySkin('onion',10110)">BUY 10,110 KSPT</button>
  </div>

  <div class="card">
    <img id="skin-img-cookie" src="knowdont.png" class="card-img">
    <div class="card-title">Crypto Cookie</div>
    <div class="card-sub">Price: 40,780 KSPT (+140 KSPT/h)</div>
    <button id="skin-cookie" onclick="buySkin('cookie',40780)">BUY 40,780 KSPT</button>
  </div>

  <div class="card" id="skinCardMystic" style="display:none">
   <img id="skin-img-mystic" src="knowdont.png" class="card-img">
   <div class="card-title">Hamster Piece</div>
    <div class="card-sub">Puzzle Reward (+15 KSPT/h)</div>
    <button id="skin-mystic" onclick="buySkin('mystic',0)">LOCKED (Complete Puzzle)</button>
  </div>

  <div class="card" id="skinCardCapsule" style="display:none">
    <img id="skin-img-capsule" src="knowdont.png" class="card-img">
    <div class="card-title">Capsule Master</div>
    <div class="card-sub">Ultra Rare Capsule Drop (+10 KSPT/h)</div>
    <button id="skin-capsule" onclick="buySkin('capsule',0)">LOCKED (Find in Capsule)</button>
  </div>

  <div class="card" id="kostiaSkinCard" style="display:none">
    <img id="skin-img-kostia" src="knowdont.png" class="card-img">
    <div class="card-title">KSPT: Community Edition</div>
    <div class="card-sub">Secret Skin (+3 KSPT/h)</div>
    <button id="skin-kostia" onclick="buySkin('kostia',0)">LOCKED (Use Promo)</button>
  </div>

  <div class="card" id="metkaSkinCard" style="display:none">
    <img id="skin-img-metka" src="knowdont.png" class="card-img">
    <div class="card-title">KSPT & RED Fingers</div>
    <div class="card-sub">Secret Skin (+5 KSPT/h)</div>
    <button id="skin-metka" onclick="buySkin('metka',0)">LOCKED (Use Promo)</button>
  </div>

  <div class="card" id="seriSkinCard" style="display:none">
    <img id="skin-img-seri" src="knowdont.png" class="card-img">
    <div class="card-title">KosTiaP Token</div>
    <div class="card-sub">Secret Skin + Animation (+5 KSPT/h)</div>
    <button id="skin-seri" onclick="buySkin('seri',0)">LOCKED (Use Promo)</button>
  </div>

  <div class="card">
    <div class="card-title">NUMBER #1!</div>
    <div class="card-sub" id="limitedSkinSub" style="color:#ff9800">Special: Win x10 Bet (+3 KSPT/h)</div>
    <button id="skin-priz" onclick="buySkin('priz',0)">LOCKED</button>
  </div>

  <button class="back" onclick="openScreen('main')">Back</button>
</div>

<div id="offlineShop" class="screen">
  <div class="top-bar">
    <img src="kspt.png">
    <span id="balanceOffline"></span>
    <img src="iks.png" class="close-x" onclick="openScreen('main')">
  </div>

  <div class="card">
    <img src="per.png" class="card-img">
    <div class="card-title">Personal Manager</div>
    <div class="card-lvl" id="c1_lvl">Not Owned</div>
    <div class="card-sub" id="c1_income">+1.0 KSPT/h</div>
    <button id="btn_c1" onclick="buyCard(1)">Buy 25 KSPT</button>
  </div>

  <div class="card" id="card2_container" style="display:none; filter: grayscale(1);">
    <img src="inv.png" class="card-img">
    <div class="card-title">Investors</div>
    <div class="card-lvl" id="c2_lvl">Locked</div>
    <div class="card-sub" id="c2_income">+2.5 KSPT/h</div>
    <button id="btn_c2" onclick="buyCard(2)">Locked</button>
  </div>

  <div class="card" id="card3_container" style="display:none; filter: grayscale(1);">
    <img src="offi.png" class="card-img">
    <div class="card-title">Office</div>
    <div class="card-lvl" id="c3_lvl">Locked</div>
    <div class="card-sub" id="c3_income">+10.2 KSPT/h</div>
    <button id="btn_c3" onclick="buyCard(3)">Locked</button>
  </div>

  <div class="card" id="card4_container">
    <img src="secu.png" class="card-img">
    <div class="card-title">Security</div>
    <div class="card-lvl" id="c4_lvl">Not Owned</div>
    <div class="card-sub" id="c4_income">+16.9 KSPT/h</div>
    <button id="btn_c4" onclick="buyCard(4)">Buy 910 KSPT</button>
  </div>

  <div class="card" id="card5_container" style="display:none; filter: grayscale(1);">
    <img src="ite.png" class="card-img">
    <div class="card-title">IT Equipment</div>
    <div class="card-lvl" id="c5_lvl">Locked</div>
    <div class="card-sub" id="c5_income">+50.1 KSPT/h</div>
    <button id="btn_c5" onclick="buyCard(5)">Locked</button>
  </div>

  <button class="back" onclick="openScreen('main')">Back</button>
</div>

<div id="tech" class="screen">
  <div class="top-bar">
    <img src="kspt.png">
    <span id="balanceTech"></span>
    <img src="iks.png" class="close-x" onclick="openScreen('main')">
  </div>

  <div class="card">
    <div class="card-title">Permanent x2</div>
    <div class="card-sub">Price: 5 KSPT</div>
    <button id="btnX2" onclick="buyX2()">Buy</button>
  </div>

  <div class="card">
    <div class="card-title">Temporary Overdrive</div>
    <div class="card-sub">x10-x20 Taps for 25+ Seconds</div>
    <div class="card-sub" id="tempBoostTimer">Cooldown: Ready</div>
    <button id="btnTempBoost" onclick="buyTempBoost()">Buy 15 KSPT</button>
  </div>

  <div class="card">
    <div class="card-title">Upgrade Energy</div>
    <div class="card-sub">Max: 10,000 | +500 Energy</div>
    <div class="card-sub" id="energyInfoText">Current Max: 2500</div>
    <button id="btnEnergyUpgrade" onclick="buyEnergyLimit()">Buy (+500) 15 KSPT</button>
  </div>
  
  <div class="card">
    <div class="card-title">Energy regeneration multiplier</div>
    <div class="card-sub" id="regenInfo">Current: 1x</div>
    <button id="btnRegen" onclick="buyRegenMult()">Upgrade</button>
  </div>

  <div class="card">
    <div class="card-title">Bet</div>
    <div class="input-group">
      <input id="betAmount" type="number" placeholder="1–30" readonly>
      <button class="max-btn" onclick="setMaxBet()">MAX</button>
    </div>
    
    <button onclick="prepareBet(1.5,30)">x1.5 (30%)</button>
    <button onclick="prepareBet(3,17)">x3 (17%)</button>
    <button onclick="prepareBet(5,8)">x5 (8%)</button>
    <button onclick="prepareBet(10,3)">x10 (3%)</button>
    <button onclick="prepareBet(50,1.1)" style="margin-top:5px; border:1px solid #ff9800; color:#ff9800">x50 (1.1%)</button>
  </div>

  <div id="betConfirm" class="card" style="display:none">
    <div id="betText"></div>
    <button class="confirm" onclick="confirmBet()">Confirm</button>
    <button class="cancel" onclick="cancelBet()">Cancel</button>
  </div>

  <div class="card promo-box">
    <div class="card-title">Enter promo code</div>
    <div class="promo-input-group">
      <input id="promoInput" type="text" placeholder="Code...">
      <button class="promo-btn" onclick="checkPromo()">Apply</button>
    </div>
  </div>

  <button class="back" onclick="openScreen('main')">Back</button>
</div>

<div class="global-nav">
  <div class="nav-item active" id="navMain" onclick="openScreen('main')">
    <div class="nav-icon" style="background: url('kspt.png') center/cover;"></div>
    <span>Main Menu</span>
  </div>
  <div class="nav-item" id="navMarket" onclick="openScreen('market')">
    <div class="nav-icon" style="background: url('k.png') center/cover;"></div>
    <span>Market</span>
  </div>
</div>

</div>

<script>
console.debug('KSPT: Initializing with all 21 fixes applied');

if (window.Telegram?.WebApp){
  Telegram.WebApp.ready();
  Telegram.WebApp.expand();
}

// Глобальные переменные
let d; // Основной объект данных
let pendingBet = null;
let lastTapTime = 0;
let currentAudio = null;
let previewTimeout = null;
let capsuleTaps = 0;
let globalSkinLimit = parseInt(localStorage.getItem("kspt_global_priz_count")) || 46;
let clickTimes = [];
let cheatStage = parseInt(localStorage.getItem("kspt_cheat_stage")) || 0;
let isWarningActive = false;
let currentMarketView = 'main';
let selectedToken = null;
let marketUpdateInterval = null;
let lastMarketBuyTime = 0;
let tradeInputValue = '';

// BUGFIX 1: Market DOM references to prevent flicker
let marketDOMRefs = {
  priceKSPT: null,
  priceBANX: null,
  pricePersonal: null,
  portfolioValue: null,
  chartCanvas: null,
  chartCtx: null,
  tradeAmount: null,
  priceContainer: null,
  priceArrow: null
};

// BUGFIX 3: Skin animation timer - REMOVED
// let skinAnimationInterval = null;
// let coinAnimTimer = null;

// BUGFIX 2: Custom keyboard for trade view
let currentKeyboardInput = null;
let tokenImageCache = localStorage.getItem('kspt_token_image_cache') || null;
let cropData = {
  image: null,
  x: 0,
  y: 0,
  scale: 1,
  isDragging: false,
  startX: 0,
  startY: 0
};

// Проверка на перманентный бан при загрузке
if(cheatStage >= 3) {
  document.getElementById("redScreen").style.display = "flex";
}

// ==========================================
// ИНИЦИАЛИЗАЦИЯ ДАННЫХ
// ==========================================
const defaultData = {
  tokens: 0,
  skin: "default",
  skins: {},
  x2: false,
  lastLogin: Date.now(),
  wonX10: false,
  cards: { c1: -1, c2: -1, c3: -1, c4: -1, c5: -1 },
  energy: 2500,
  maxEnergy: 2500,
  usedCodes: [],
  bg: "default",
  ownedBgs: ["default"],
  boost: { active: false, end: 0, cdEnd: 0 },
  euroVar: 1,
  regenMult: 1,
  vibration: 'medium',
  puzzles: [0,0,0,0,0,0,0,0,0],
  puzzleDone: false,
  capsule: { lastOpen: 0, firstOpen: true },
  bonuses: { 
    offline25: false, 
    tap2x: { active: false, end: 0 }, 
    discounts: {},
    usedBezBags: false // BUGFIX 6: Added BezBags tracking
  },
  music: "mistic",
  ownedMusic: ["mistic"],
  musicMuted: false,
  market: {
    introSeen: false,
    account: { name: "Trader", desc: "Crypto enthusiast" },
    ksptToken: {
      owned: 0,
      lastBuyTime: 0,
      price: 0.50,
      history: [0.50, 0.50, 0.50, 0.50, 0.50],
      lastUpdate: Date.now()
    },
    banxToken: {
      owned: 0,
      lastBuyTime: 0,
      price: 0.0021,
      history: [0.0021, 0.0021, 0.0021, 0.0021, 0.0021],
      lastUpdate: Date.now()
    },
    personalToken: null
  }
};

// Загрузка данных
try {
  const savedData = localStorage.getItem("kspt");
  if (savedData) {
    d = JSON.parse(savedData);
    // Миграция старых данных
    d = migrateData(d, defaultData);
  } else {
    d = JSON.parse(JSON.stringify(defaultData));
  }
} catch(e) {
  console.error("Error loading data:", e);
  d = JSON.parse(JSON.stringify(defaultData));
}

function migrateData(oldData, defaultData) {
  const merged = {...defaultData};
  
  // Копируем все существующие свойства
  for (const key in oldData) {
    if (oldData.hasOwnProperty(key)) {
      if (typeof oldData[key] === 'object' && !Array.isArray(oldData[key])) {
        merged[key] = {...merged[key], ...oldData[key]};
      } else {
        merged[key] = oldData[key];
      }
    }
  }
  
  // Убедимся, что важные поля существуют
  if (!merged.skins) merged.skins = {};
  if (!merged.bonuses) merged.bonuses = defaultData.bonuses;
  if (!merged.market) merged.market = defaultData.market;
  
  return merged;
}

const save = () => {
  console.debug('save: called at', Date.now());
  try {
    localStorage.setItem("kspt", JSON.stringify(d));
  } catch(e) {
    console.error("Error saving data:", e);
  }
};

// Данные о доходах от скинов
const SKIN_INCOME = {
  default: 0,
  what: 1,
  burger: 2.2,
  joost: 4,
  dog: 6.7,
  diam: 10,
  tung: 15,
  priz: 3,
  euro: 27,
  space: 40,
  kostia: 3,
  pixe: 88,    
  onion: 120,
  cookie: 140,
  metka: 5,
  seri: 5,
  mystic: 15,
  capsule: 10
};

const CARDS = {
  1: { levels: [{ price: 25, income: 1.0 }, { price: 32, income: 2.1 }, { price: 40, income: 2.8 }, { price: 51, income: 4.4 }, { price: 65, income: 5.1 }, { price: 80, income: 6.5 }] },
  2: { levels: [{ price: 100, income: 2.5 }, { price: 130, income: 3.8 }, { price: 170, income: 5.1 }, { price: 190, income: 6.7 }, { price: 250, income: 8.0 }, { price: 315, income: 10.0 }] },
  3: { levels: [{ price: 310, income: 10.2 }, { price: 390, income: 14.1 }, { price: 480, income: 21 }, { price: 540, income: 28.6 }, { price: 610, income: 35.8 }, { price: 760, income: 50.3 }] },
  4: { levels: [{ price: 910, income: 16.9 }, { price: 1110, income: 27.1 }, { price: 1280, income: 35.7 }, { price: 1410, income: 48.0 }, { price: 1670, income: 59.3 }, { price: 1860, income: 74.2 }] },
  5: { levels: [{ price: 1470, income: 50.1 }, { price: 1970, income: 73.4 }, { price: 2510, income: 86.7 }, { price: 3120, income: 108.5 }, { price: 3510, income: 138.3 }, { price: 4080, income: 215.4 }] }
};

// ==========================================
// ОСНОВНЫЕ ФУНКЦИИ
// ==========================================

function processOfflineIncome() {
  try {
    const now = Date.now();
    const diffMs = now - d.lastLogin;
    const minutes = diffMs / (1000 * 60);
    const hours = diffMs / (1000 * 60 * 60);
    let rate = getHourlyRate();
    
    if (rate > 0 && hours >= 1) {
      let effectiveHours = hours;
      if (effectiveHours > 8) effectiveHours = 8;
      
      let earnings = rate * effectiveHours;
      if (d.bonuses && d.bonuses.offline25) {
        earnings *= 1.25;
        d.bonuses.offline25 = false;
        showToast("Offline Bonus Applied! +25% Income");
      }

      if (earnings > 0.01) {
        d.tokens += earnings;
        showToast(`While you were away, you earned ${earnings.toFixed(2)} KSPT.`);
      }
    }

    // Логика восстановления энергии
    let energyPercent = 0;
    if (minutes >= 5 && minutes < 10) {
      energyPercent = 0.10;
    } else if (minutes >= 10 && minutes < 25) {
      energyPercent = 0.25;
    } else if (minutes >= 25 && minutes < 40) {
      energyPercent = 0.50;
    } else if (minutes >= 40 && minutes < 70) {
      energyPercent = 0.75;
    } else if (minutes >= 70) {
      energyPercent = 1.0;
    }

    if (energyPercent > 0) {
      let add = d.maxEnergy * energyPercent;
      d.energy = Math.min(d.energy + add, d.maxEnergy);
    }

    // Обработка оффлайн рынка
    processOfflineMarket(minutes);

    d.lastLogin = now;
    save();
  } catch(e) {
    console.error("Offline Process Error", e);
  }
}

function processOfflineMarket(minutes) {
  if(!d.market || !d.market.ksptToken) return;
  
  // KSPT Token
  let range = 0;
  if(minutes >= 0 && minutes < 10) range = 1;
  else if(minutes >= 10 && minutes < 30) range = 2;
  else if(minutes >= 30) range = 3;
  
  if(range > 0) {
    let change = 0;
    let sign = Math.random() < 0.5 ? -1 : 1;
    
    if(range === 1) change = (Math.random() * 0.04) + 0.03;
    else if(range === 2) change = (Math.random() * 0.05) + 0.10;
    else if(range === 3) change = (Math.random() * 0.25) + 0.15;
    
    let newPrice = d.market.ksptToken.price + (change * sign);
    if(newPrice < 0.10) newPrice = 0.10;
    if(newPrice > 2.80) newPrice = 2.80;
    
    d.market.ksptToken.price = newPrice;
    d.market.ksptToken.history.push(newPrice);
    if(d.market.ksptToken.history.length > 20) d.market.ksptToken.history.shift();
  }
  
  // BANX Token
  if(d.market.banxToken) {
    let banxRange = 0;
    if(minutes >= 0 && minutes < 10) banxRange = 1;
    else if(minutes >= 10 && minutes < 30) banxRange = 2;
    else if(minutes >= 30) banxRange = 3;
    
    if(banxRange > 0) {
      let banxChange = 0;
      let banxSign = Math.random() < 0.5 ? -1 : 1;
      
      if(banxRange === 1) banxChange = (Math.random() * 0.0001) + 0.0002;
      else if(banxRange === 2) banxChange = (Math.random() * 0.0002) + 0.0005;
      else if(banxRange === 3) banxChange = (Math.random() * 0.0003) + 0.0006;
      
      let newBanxPrice = d.market.banxToken.price + (banxChange * banxSign);
      if(newBanxPrice < 0.0007) newBanxPrice = 0.0007;
      if(newBanxPrice > 0.01) newBanxPrice = 0.01;
      
      d.market.banxToken.price = newBanxPrice;
      d.market.banxToken.history.push(newBanxPrice);
      if(d.market.banxToken.history.length > 20) d.market.banxToken.history.shift();
    }
  }
  
  // Personal Token
  if(d.market.personalToken) {
    let personalRange = 0;
    if(minutes >= 0 && minutes < 10) personalRange = 1;
    else if(minutes >= 10 && minutes < 30) personalRange = 2;
    else if(minutes >= 30) personalRange = 3;
    
    if(personalRange > 0) {
      let personalChangePercent = 0;
      let personalSign = Math.random() < 0.5 ? -1 : 1;
      
      if(personalRange === 1) personalChangePercent = (Math.random() * 0.03) + 0.06;
      else if(personalRange === 2) personalChangePercent = (Math.random() * 0.06) + 0.10;
      else if(personalRange === 3) personalChangePercent = (Math.random() * 0.06) + 0.15;
      
      let changeAmount = d.market.personalToken.price * personalChangePercent;
      let newPersonalPrice = d.market.personalToken.price + (changeAmount * personalSign);
      
      if(newPersonalPrice < 0.001) newPersonalPrice = 0.001;
      if(newPersonalPrice > 10) newPersonalPrice = 10;
      
      d.market.personalToken.price = newPersonalPrice;
      d.market.personalToken.history.push(newPersonalPrice);
      if(d.market.personalToken.history.length > 20) d.market.personalToken.history.shift();
    }
  }
}

function getHourlyRate() {
  let rate = 0;
  if(d.cards.c1 >= 0) rate += CARDS[1].levels[d.cards.c1].income;
  if(d.cards.c2 >= 0) rate += CARDS[2].levels[d.cards.c2].income;
  if(d.cards.c3 >= 0) rate += CARDS[3].levels[d.cards.c3].income;
  if(d.cards.c4 >= 0) rate += CARDS[4].levels[d.cards.c4].income;
  if(d.cards.c5 >= 0) rate += CARDS[5].levels[d.cards.c5].income;

  rate += SKIN_INCOME.default;
  
  if(d.skins) {
    for(let s in d.skins) {
      if(d.skins[s] && SKIN_INCOME[s]) {
        rate += SKIN_INCOME[s];
      }
    }
  }
  if(d.wonX10) rate += SKIN_INCOME.priz;
  return rate;
}

// ==========================================
// UI ФУНКЦИИ
// ==========================================

// BUGFIX 9: UI stability with requestAnimationFrame
function safeDOMUpdate(callback) {
  if (typeof requestAnimationFrame !== 'undefined') {
    requestAnimationFrame(() => {
      callback();
    });
  } else {
    setTimeout(callback, 0);
  }
}

function ui() {
  if(!d) return;
  
  // BUGFIX 9: Use requestAnimationFrame for batch updates
  safeDOMUpdate(() => {
    // Обновление балансов
    const elements = {
      "balanceMain": d.tokens.toFixed(2) + " KSPT",
      "balanceSkins": "Balance: " + d.tokens.toFixed(2) + " KSPT",
      "balanceTech": "Balance: " + d.tokens.toFixed(2) + " KSPT",
      "balanceOffline": "Balance: " + d.tokens.toFixed(2) + " KSPT",
      "balanceSettings": "Balance: " + d.tokens.toFixed(2) + " KSPT",
      "balanceCapsule": "Balance: " + d.tokens.toFixed(2) + " KSPT"
    };
    
    for (const [id, text] of Object.entries(elements)) {
      const elem = document.getElementById(id);
      if (elem) elem.textContent = text;
    }
    
    let rate = getHourlyRate();
    const offlineElem = document.getElementById("offlineRateMain");
    if (offlineElem) offlineElem.textContent = "Offline: " + rate.toFixed(1) + " KSPT/h";
    
    const skinSubElem = document.getElementById("limitedSkinSub");
    if (skinSubElem) skinSubElem.textContent = `Special: Win x10 Bet (Limited ${globalSkinLimit} left) (+3 KSPT/h)`;
    
    const energyElem = document.getElementById("energyDisplay");
    if (energyElem) energyElem.textContent = `${Math.floor(d.energy)} / ${d.maxEnergy}`;
    
    const energyInfoElem = document.getElementById("energyInfoText");
    if (energyInfoElem) energyInfoElem.textContent = `Current Max: ${d.maxEnergy}`;
  });
  
  // Critical updates that need immediate render
  updateBackground();
  updateTempBoostUI();
  updateCapsuleUI();
  updateSkinImage(); // BUGFIX 3: This now only updates if skin changed
  updateSkinButtons();
  updateSettingsUI();
  updateRegenUI();
  updateCardUI();
  updatePuzzleUI();
  
  // BUGFIX 4: Update skin previews
  updateSkinPreviews();
  
  // Market UI updates handled separately to avoid flicker
  if (!document.getElementById("market")?.classList.contains("active")) {
    updateMarketUI();
  }
  
  // Update maxed buttons
  updateMaxedButtons();
}

function updateMaxedButtons() {
  // ×2 Multiplier
  const x2Btn = document.getElementById("btnX2");
  if (x2Btn) {
    if (d.x2) {
      x2Btn.textContent = "MAXED";
      x2Btn.className = "owned";
      x2Btn.onclick = null;
    } else {
      x2Btn.textContent = "Buy";
      x2Btn.className = "";
      x2Btn.onclick = buyX2;
    }
  }
  
  // BUGFIX 8: Energy Upgrade with updated costs and max limit
  const energyBtn = document.getElementById("btnEnergyUpgrade");
  if (energyBtn) {
    if (d.maxEnergy >= 10000) { // BUGFIX 8: Increased to 10000
      energyBtn.textContent = "MAXED";
      energyBtn.className = "owned";
      energyBtn.onclick = null;
    } else {
      let cost = 15;
      if (d.maxEnergy >= 8000) {
        cost = 100; // BUGFIX 8: Changed to 100 KSPT
      }
      energyBtn.textContent = `Buy (+500) ${cost} KSPT`;
      energyBtn.className = "";
      energyBtn.onclick = buyEnergyLimit;
    }
  }
  
  // BUGFIX 8: Regen Multiplier updated for 2.5x and 3x
  const regenBtn = document.getElementById("btnRegen");
  if (regenBtn) {
    if (d.regenMult === 3) {
      regenBtn.textContent = "MAXED";
      regenBtn.className = "owned";
      regenBtn.onclick = null;
    }
  }
}

// BUGFIX 3: Update skin image to show immediately and initialize animations - FIXED VERSION
function updateSkinImage() {
  const coin = document.getElementById("coin");
  if (!coin) return;

  let imgName = "kspt.png";
  if(d.skin === "what") imgName = "what.png";
  else if(d.skin === "burger") imgName = "burger.png";
  else if(d.skin === "joost") imgName = "joost.png";
  else if(d.skin === "dog") imgName = "dog.png";
  else if(d.skin === "diam") imgName = "diam.png";
  else if(d.skin === "priz") imgName = "priz.png";
  else if(d.skin === "tung") imgName = "tung.png";
  else if(d.skin === "euro") imgName = d.euroVar === 2 ? "e2.png" : "e1.png";
  else if(d.skin === "space") imgName = "sun.png";
  else if(d.skin === "kostia") imgName = "kostia.png";
  else if(d.skin === "pixe") imgName = "pixe.png";
  else if(d.skin === "onion") imgName = "onion.png";
  else if(d.skin === "metka") imgName = "metka.png";
  else if(d.skin === "seri") imgName = "seri.png";
  else if(d.skin === "capsule") imgName = "capskine.png";
  else if(d.skin === "mystic") imgName = "piece.png";
  else if(d.skin === "cookie") imgName = "cook.png"; // new skin

  // *** ONLY update the DOM if the skin actually changed ***
  if (coin.dataset.currentSkin !== d.skin) {
    coin.src = imgName;
    coin.dataset.currentSkin = d.skin;
    // Reset per-skin stage counters
    coin.dataset.toggle = "0";
    coin.dataset.stage = "0";
    coin.dataset.mystic = "0";
    coin.dataset.cookStage = "0";
  }
}

// BUGFIX 3: Make animation happen only on tap - FIXED VERSION
function handleSkinAnimation() {
  const coin = document.getElementById('coin');
  if (!coin) return;

  switch(d.skin) {
    case "tung":
      coin.src = coin.src.includes("tung1.png") ? "tung.png" : "tung1.png";
      break;
    case "space":
      coin.src = coin.src.includes("sun.png") ? "moon.png" : "sun.png";
      break;
    case "pixe":
      coin.dataset.toggle = coin.dataset.toggle === "1" ? "0" : "1";
      coin.src = coin.dataset.toggle === "1" ? "pixe1.png" : "pixe.png";
      break;
    case "onion":
      let stage = parseInt(coin.dataset.stage || "0", 10);
      stage = (stage + 1) % 3;
      coin.dataset.stage = stage;
      if (stage === 0) coin.src = "onion.png";
      if (stage === 1) coin.src = "onion1.png";
      if (stage === 2) coin.src = "onion2.png";
      break;
    case "seri":
      coin.dataset.toggle = coin.dataset.toggle === "1" ? "0" : "1";
      coin.src = coin.dataset.toggle === "1" ? "seri1.png" : "seri.png";
      break;
    case "mystic":
      let mysticStage = parseInt(coin.dataset.mystic || "0", 10);
      mysticStage = (mysticStage + 1) % 4;
      coin.dataset.mystic = mysticStage;
      if (mysticStage === 0) coin.src = "piece1.png";
      if (mysticStage === 1) coin.src = "piece2.png";
      if (mysticStage === 2) coin.src = "piece3.png";
      if (mysticStage === 3) coin.src = "piece.png";
      break;
    case "capsule":
      coin.dataset.toggle = coin.dataset.toggle === "1" ? "0" : "1";
      coin.src = coin.dataset.toggle === "1" ? "capskine1.png" : "capskine.png";
      break;
    case "cookie": // NEW: cycle on each tap: cook.png -> cook1.png -> cook2.png -> cook.png
      let cstage = parseInt(coin.dataset.cookStage || "0", 10);
      cstage = (cstage + 1) % 3;
      coin.dataset.cookStage = cstage;
      if (cstage === 0) coin.src = "cook.png";
      else if (cstage === 1) coin.src = "cook1.png";
      else if (cstage === 2) coin.src = "cook2.png";
      break;
    default:
      // no animation for other skins
      break;
  }
}

function updateSkinButtons() {
  // Показ/скрытие секретных скинов
  const secretSkins = {
    "kostiaSkinCard": 'kostia',
    "metkaSkinCard": 'metka',
    "seriSkinCard": 'seri',
    "skinCardMystic": 'mystic',
    "skinCardCapsule": 'capsule'
  };
  
  for (const [cardId, skinKey] of Object.entries(secretSkins)) {
    const card = document.getElementById(cardId);
    if (card) {
      card.style.display = d.skins && d.skins[skinKey] ? "block" : "none";
    }
  }
  
  // Обновление кнопок скинов
  const skins = ["default", "what", "burger", "joost", "dog", "diam", "tung", "priz", "euro", "space", "kostia", "pixe", "onion", "cookie", "metka", "seri", "mystic", "capsule"];
  
  skins.forEach(s => {
    const button = document.getElementById("skin-" + s);
    if (!button) return;
    
    if (s === "priz") {
      if (d.skin === "priz") {
        button.textContent = "ACTIVE";
        button.className = "active";
        return;
      }
      if (d.wonX10 && globalSkinLimit > 0) {
        button.textContent = "OWNED";
        button.className = "owned";
        button.onclick = () => buySkin('priz', 0);
      } else {
        button.textContent = globalSkinLimit <= 0 ? "SOLD OUT" : "LOCKED (Win x10)";
        button.className = "owned";
        button.onclick = null;
      }
      return;
    }
    
    if (d.skin === s) {
      button.textContent = s === "euro" ? `ACTIVE (Var ${d.euroVar})` : "ACTIVE";
      button.className = "active";
    } else if (s === "default" || d.skins[s]) {
      button.textContent = "OWNED";
      button.className = "owned";
    } else {
      const prices = {what:1, burger:10, joost:30, dog:80, diam:100, tung:240, euro:780, space:1210, kostia:0, pixe:3215, onion:10110, cookie:40780, metka:0, seri:0, mystic:0, capsule:0};
      
      if (s === "mystic") {
        button.textContent = "LOCKED (Complete Puzzle)";
      } else if (s === "capsule") {
        button.textContent = "LOCKED (Find in Capsule)";
      } else if (s !== "kostia" && s !== "metka" && s !== "seri") {
        let cost = prices[s];
        if (d.bonuses.discounts && d.bonuses.discounts[s] && Date.now() < d.bonuses.discounts[s]) {
          let discounted = Math.floor(cost * 0.85);
          button.innerHTML = `<span style="text-decoration:line-through; color:red; font-size:11px;">${cost}</span> BUY ${discounted} KSPT`;
        } else {
          button.textContent = `BUY ${cost} KSPT`;
        }
      } else {
        button.textContent = "LOCKED (Use Code)";
      }
      button.className = "";
    }
  });
}

// BUGFIX 4: Shop previews show knowdont.png for unowned skins
function updateSkinPreviews() {
  const skinImageMap = {
    'what': 'what.png',
    'burger': 'burger.png',
    'joost': 'joost.png',
    'dog': 'dog.png',
    'diam': 'diam.png',
    'tung': 'tung.png',
    'euro': 'e1.png',
    'space': 'sun.png',
    'pixe': 'pixe.png',
    'onion': 'onion.png',
    'cookie': 'cook.png',
    'mystic': 'piece.png',
    'capsule': 'capskine.png',
    'kostia': 'kostia.png',
    'metka': 'metka.png',
    'seri': 'seri.png'
  };
  
  for (const [skin, img] of Object.entries(skinImageMap)) {
    const imgElement = document.getElementById(`skin-img-${skin}`);
    if (imgElement) {
      // BUGFIX 4: Show knowdont.png if not owned, real image if owned
      let isOwned = false;
      if (skin === 'mystic') {
        isOwned = d.puzzleDone;
      } else if (skin === 'capsule') {
        isOwned = d.skins['capsule'];
      } else if (skin === 'kostia' || skin === 'metka' || skin === 'seri') {
        isOwned = d.skins[skin] || false;
      } else {
        isOwned = d.skins[skin] || false;
      }
      
      if (isOwned) {
        imgElement.src = img;
      } else {
        imgElement.src = 'knowdont.png';
      }
    }
  }
}

function updateBackground() {
  const now = Date.now();
  const body = document.body;
  
  if (!body) return;
  
  // Приоритет 1: Fire BG (Tap x2 Bonus)
  if (d.bonuses.tap2x.active && now < d.bonuses.tap2x.end) {
    body.style.backgroundImage = "url('fire.png')";
    body.style.backgroundColor = "transparent";
    return;
  } else if (d.bonuses.tap2x.active && now >= d.bonuses.tap2x.end) {
    d.bonuses.tap2x.active = false;
  }
  
  // Приоритет 2: Boost Active
  if (d.boost.active && now < d.boost.end) {
    body.style.backgroundImage = "url('ogon.png')";
    body.style.backgroundColor = "#220000";
  } else {
    if (d.boost.active && now >= d.boost.end) {
      d.boost.active = false;
    }
    
    // Приоритет 3: Выбранный фон
    switch(d.bg) {
      case "default":
        body.style.backgroundImage = "none";
        body.style.backgroundColor = "#0b0b0b";
        break;
      case "forest":
        body.style.backgroundImage = "url('forest.png')";
        body.style.backgroundColor = "transparent";
        break;
      case "space":
        body.style.backgroundImage = "url('star.png')";
        body.style.backgroundColor = "transparent";
        break;
      case "ric":
        body.style.backgroundImage = "url('ric.png')";
        body.style.backgroundColor = "transparent";
        break;
      case "heaven":
        body.style.backgroundImage = "url('heaven.png')";
        body.style.backgroundColor = "transparent";
        break;
      case "bug":
        body.style.backgroundImage = "url('bug.png')";
        body.style.backgroundColor = "transparent";
        break;
      default:
        body.style.backgroundImage = "none";
        body.style.backgroundColor = "#0b0b0b";
    }
  }
}

function updateTempBoostUI() {
  const btn = document.getElementById("btnTempBoost");
  const txt = document.getElementById("tempBoostTimer");
  if (!btn || !txt) return;
  
  const now = Date.now();
  if (d.boost.active && now < d.boost.end) {
    let secLeft = Math.ceil((d.boost.end - now) / 1000);
    txt.textContent = `ACTIVE! ${secLeft}s left`;
    txt.style.color = "#ff0000";
    btn.textContent = "Active";
    btn.className = "active";
    btn.onclick = null;
  } else if (now < d.boost.cdEnd) {
    let minLeft = Math.ceil((d.boost.cdEnd - now) / 60000);
    txt.textContent = `Cooldown: ${minLeft}m`;
    txt.style.color = "#aaa";
    btn.textContent = "Cooldown";
    btn.className = "owned";
    btn.onclick = null;
  } else {
    txt.textContent = "Cooldown: Ready";
    txt.style.color = "#2e7d32";
    btn.textContent = "Buy 15 KSPT";
    btn.className = "";
    btn.onclick = buyTempBoost;
  }
}

// BUGFIX 8: Updated regen UI for 2.5x and 3x
function updateRegenUI() {
  const btn = document.getElementById("btnRegen");
  const info = document.getElementById("regenInfo");
  if (!btn || !info) return;
  
  let m = d.regenMult;
  if (m === 1) {
    info.textContent = "Current: 1x";
    btn.textContent = "Upgrade to 1.5x (40 KSPT)";
    btn.onclick = buyRegenMult;
  } else if (m === 1.5) {
    info.textContent = "Current: 1.5x";
    btn.textContent = "Upgrade to 2x (70 KSPT)";
    btn.onclick = buyRegenMult;
  } else if (m === 2) {
    info.textContent = "Current: 2x";
    btn.textContent = "Upgrade to 2.5x (140 KSPT)"; // BUGFIX 8: Added 2.5x
    btn.onclick = buyRegenMult;
  } else if (m === 2.5) {
    info.textContent = "Current: 2.5x";
    btn.textContent = "Upgrade to 3x (140 KSPT)"; // BUGFIX 8: Added 3x
    btn.onclick = buyRegenMult;
  } else {
    info.textContent = "Current: 3x (MAX)";
    btn.textContent = "MAXED";
    btn.className = "owned";
    btn.onclick = null;
    return;
  }
  btn.className = "";
}

function updateCardUI() {
  for (let i = 1; i <= 5; i++) {
    const key = "c" + i;
    const lvl = d.cards[key];
    const data = CARDS[i].levels;
    const btn = document.getElementById("btn_c" + i);
    const txtLvl = document.getElementById("c" + i + "_lvl");
    const txtInc = document.getElementById("c" + i + "_income");
    
    if (!btn || !txtLvl || !txtInc) continue;
    
    if (lvl === 5) {
      txtLvl.textContent = "Level: MAX";
      txtInc.textContent = "+" + data[5].income + " KSPT/h";
      btn.textContent = "MAXED";
      btn.className = "owned";
      btn.onclick = null;
    } else {
      let nextLvl = lvl + 1;
      let cost = data[nextLvl].price;
      let nextInc = data[nextLvl].income;
      
      if (lvl === -1) {
        txtLvl.textContent = "Not Owned";
        txtInc.textContent = "+" + nextInc + " KSPT/h";
        btn.textContent = `Buy ${cost} KSPT`;
      } else {
        txtLvl.textContent = `Level: ${lvl}`;
        txtInc.textContent = `Current: +${data[lvl].income} -> +${nextInc}`;
        btn.textContent = `Upgrade ${cost} KSPT`;
      }
      btn.className = "";
      btn.onclick = () => buyCard(i);
    }
  }
  
  // Управление видимостью карт
  const c2Div = document.getElementById("card2_container");
  if (c2Div) {
    if (d.cards.c1 >= 3) {
      c2Div.style.display = "block";
      c2Div.style.filter = "none";
    } else {
      c2Div.style.display = "block";
      c2Div.style.filter = "grayscale(1) opacity(0.5)";
      const btn = document.getElementById("btn_c2");
      if (btn) btn.textContent = "Unlock: Card #1 Lvl 3";
    }
  }
  
  const c3Div = document.getElementById("card3_container");
  if (c3Div) {
    if (d.cards.c2 >= 1) {
      c3Div.style.display = "block";
      c3Div.style.filter = "none";
    } else {
      c3Div.style.display = "block";
      c3Div.style.filter = "grayscale(1) opacity(0.5)";
      const btn = document.getElementById("btn_c3");
      if (btn) btn.textContent = "Unlock: Card #2 Lvl 2";
    }
  }
  
  const c5Div = document.getElementById("card5_container");
  if (c5Div) {
    if (d.cards.c4 >= 3) {
      c5Div.style.display = "block";
      c5Div.style.filter = "none";
    } else {
      c5Div.style.display = "block";
      c5Div.style.filter = "grayscale(1) opacity(0.5)";
      const btn = document.getElementById("btn_c5");
      if (btn) btn.textContent = "Unlock: Security Lvl 4";
    }
  }
}

function updatePuzzleUI() {
  let ownedCount = 0;
  for (let i = 0; i < 9; i++) {
    const cell = document.getElementById("pz" + (i + 1));
    if (cell) {
      if (d.puzzles[i] === 1) {
        cell.classList.add("filled");
        ownedCount++;
      } else {
        cell.classList.remove("filled");
      }
    }
  }
  
  const statusElem = document.getElementById("puzzleStatus");
  if (statusElem) statusElem.textContent = `Owned: ${ownedCount}/9`;
  
  const fullImg = document.getElementById("puzzleFull");
  const completedText = document.getElementById("puzzleCompletedText");
  const placeBtn = document.getElementById("btnPlacePiece");
  
  if (ownedCount === 9 && !d.puzzleDone) {
    d.puzzleDone = true;
    if (!d.skins['mystic']) {
      d.skins['mystic'] = 1;
      showToast("PUZZLE COMPLETE! Hamster Piece Skin Unlocked!");
    }
  }
  
  if (d.puzzleDone) {
    if (fullImg) fullImg.style.display = "block";
    if (completedText) completedText.style.display = "block";
    if (placeBtn) placeBtn.style.display = "none";
  } else {
    if (fullImg) fullImg.style.display = "none";
    if (completedText) completedText.style.display = "none";
    if (placeBtn) placeBtn.style.display = ownedCount > 0 ? "block" : "none";
  }
}

function updateCapsuleUI() {
  const btn = document.getElementById("btnOpenCapsule");
  const txt = document.getElementById("capsuleTimer");
  if (!btn || !txt) return;
  
  const now = Date.now();
  const cooldownTime = 23 * 60 * 60 * 1000;
  
  if (d.capsule.firstOpen) {
    txt.textContent = "First Open Free!";
    btn.style.background = "#ff9800";
    btn.textContent = "OPEN!";
    btn.onclick = startCapsuleSequence;
    return;
  }
  
  let diff = now - d.capsule.lastOpen;
  if (diff >= cooldownTime) {
    txt.textContent = "Ready to open!";
    btn.style.background = "#ff9800";
    btn.textContent = "OPEN!";
    btn.className = "";
    btn.onclick = startCapsuleSequence;
  } else {
    let wait = cooldownTime - diff;
    let h = Math.floor(wait / (1000 * 60 * 60));
    let m = Math.floor((wait % (1000 * 60 * 60)) / (1000 * 60));
    txt.textContent = `Cooldown: ${h}h ${m}m`;
    btn.style.background = "#333";
    btn.textContent = "Wait";
    btn.className = "owned";
    btn.onclick = null;
  }
}

function updateSettingsUI() {
  if (!document.getElementById('settings')?.classList.contains('active')) return;
  
  // Фоны
  const bgButtons = [
    {id: 'bg-btn-default', key: 'default', price: 0},
    {id: 'bg-btn-forest', key: 'forest', price: 320},
    {id: 'bg-btn-space', key: 'space', price: 0},
    {id: 'bg-btn-ric', key: 'ric', price: 5120},
    {id: 'bg-btn-heaven', key: 'heaven', price: 0},
    {id: 'bg-btn-bug', key: 'bug', price: 0}
  ];
  
  bgButtons.forEach(bg => {
    const btn = document.getElementById(bg.id);
    if (!btn) return;
    
    if (d.bg === bg.key) {
      btn.textContent = "Selected";
      btn.className = "active";
    } else if (d.ownedBgs.includes(bg.key)) {
      btn.textContent = "Select";
      btn.className = "";
      btn.onclick = () => equipBackground(bg.key);
    } else {
      if (bg.key === 'space') {
        btn.textContent = "Locked (Buy Space Skin)";
        btn.className = "owned";
        btn.onclick = null;
      } else if (bg.key === 'heaven') {
        btn.textContent = "Locked (Capsule Drop)";
        btn.className = "owned";
        btn.onclick = null;
      } else if (bg.key === 'bug') {
        btn.textContent = "Locked (Buy Pixel Skin)";
        btn.className = "owned";
        btn.onclick = null;
      } else {
        btn.textContent = `Buy ${bg.price} KSPT`;
        btn.onclick = () => buyBackground(bg.key, bg.price);
      }
    }
  });
  
  // Вибрация
  const vibButtons = [
    {id: "vib-off", level: "off"},
    {id: "vib-low", level: "low"},
    {id: "vib-med", level: "medium"},
    {id: "vib-str", level: "strong"}
  ];
  
  vibButtons.forEach(vib => {
    const btn = document.getElementById(vib.id);
    if (btn) {
      if (d.vibration === vib.level) {
        btn.classList.add("active");
        btn.style.background = "#2e7d32";
      } else {
        btn.classList.remove("active");
        btn.style.background = "#262626";
      }
    }
  });
  
  // Музыка
  updateMusicUI();
}

function updateMusicUI() {
  // Mystic
  const misticBtn = document.getElementById("btn-music-mistic");
  if (misticBtn) {
    if (d.music === "mistic" && !d.musicMuted) {
      misticBtn.textContent = "Active";
      misticBtn.className = "active";
    } else {
      misticBtn.textContent = "Select";
      misticBtn.className = "";
    }
  }
  
  // Gabber
  const gabberBtn = document.getElementById("btn-music-gabber");
  if (gabberBtn) {
    if (d.music === "gabber" && !d.musicMuted) {
      gabberBtn.textContent = "Active";
      gabberBtn.className = "active";
      gabberBtn.onclick = () => setMusic('gabber');
    } else if (d.ownedMusic.includes("gabber")) {
      gabberBtn.textContent = "Select";
      gabberBtn.className = "";
      gabberBtn.onclick = () => setMusic('gabber');
    } else {
      gabberBtn.textContent = "Buy 210 KSPT";
      gabberBtn.className = "";
      gabberBtn.onclick = () => buyMusic('gabber', 210);
    }
  }
  
  // Onion
  const onionRow = document.getElementById("music-onion-row");
  if (onionRow) onionRow.style.display = "flex";
  
  const onionBtn = document.getElementById("btn-music-onion");
  if (onionBtn) {
    if (d.skins["onion"]) {
      if (d.music === "onion" && !d.musicMuted) {
        onionBtn.textContent = "Active";
        onionBtn.className = "active";
      } else {
        onionBtn.textContent = "Select";
        onionBtn.className = "";
      }
      onionBtn.onclick = () => setMusic('onion');
    } else {
      onionBtn.textContent = "Locked (Buy Skin)";
      onionBtn.className = "owned";
      onionBtn.onclick = null;
    }
  }
  
  // Calm
  const calmBtn = document.getElementById("btn-music-calm");
  if (calmBtn) {
    if (d.ownedMusic.includes("calm")) {
      if (d.music === "calm" && !d.musicMuted) {
        calmBtn.textContent = "Active";
        calmBtn.className = "active";
      } else {
        calmBtn.textContent = "Select";
        calmBtn.className = "";
      }
      calmBtn.onclick = () => setMusic('calm');
    } else {
      calmBtn.textContent = "Locked (Find in Capsule)";
      calmBtn.className = "owned";
      calmBtn.onclick = null;
    }
  }
}

// BUGFIX 1: Initialize market references
function initMarketReferences() {
  marketDOMRefs.priceKSPT = document.getElementById('price-ksptToken-value');
  marketDOMRefs.priceBANX = document.getElementById('price-banxToken-value');
  marketDOMRefs.pricePersonal = document.getElementById('price-personalToken-value');
  marketDOMRefs.portfolioValue = document.getElementById('market-portfolio-value');
  marketDOMRefs.chartCanvas = document.getElementById('priceChart');
  if (marketDOMRefs.chartCanvas) {
    marketDOMRefs.chartCtx = marketDOMRefs.chartCanvas.getContext('2d');
  }
  marketDOMRefs.tradeAmount = document.getElementById('tradeAmount');
  marketDOMRefs.priceContainer = document.getElementById('trade-price-container');
  marketDOMRefs.priceArrow = document.getElementById('trade-price-arrow');
}

// BUGFIX 1 & 2: Update market prices without causing flickering and update all tokens
function updateMarketPrices() {
  if (!document.getElementById("market")?.classList.contains("active")) {
    return;
  }
  
  // BUGFIX 1: Preserve input state before any updates
  let inputValue = '';
  let inputSelection = {start: 0, end: 0};
  let hadFocus = false;
  
  if (marketDOMRefs.tradeAmount) {
    inputValue = marketDOMRefs.tradeAmount.value;
    inputSelection.start = marketDOMRefs.tradeAmount.selectionStart;
    inputSelection.end = marketDOMRefs.tradeAmount.selectionEnd;
    hadFocus = (document.activeElement === marketDOMRefs.tradeAmount);
    console.debug('market:preserve-input', marketDOMRefs.tradeAmount.id, inputValue);
  }
  
  const now = Date.now();
  
  if (currentMarketView === 'trade') {
    updateBuyCooldownInfo();
  }
  
  // BUGFIX 2: Update all tokens (not just the viewed one)
  updateTokenPriceData('ksptToken');
  updateTokenPriceData('banxToken');
  if (d.market.personalToken) {
    updateTokenPriceData('personalToken');
  }
  
  // Update DOM elements directly without rebuilding
  if (currentMarketView === 'main') {
    if (marketDOMRefs.priceKSPT) {
      marketDOMRefs.priceKSPT.textContent = d.market.ksptToken.price.toFixed(2);
    }
    
    if (marketDOMRefs.priceBANX) {
      marketDOMRefs.priceBANX.textContent = d.market.banxToken.price.toFixed(4);
    }
    
    if (marketDOMRefs.pricePersonal && d.market.personalToken) {
      marketDOMRefs.pricePersonal.textContent = d.market.personalToken.price.toFixed(4);
    }
    
    // Update portfolio value
    if (marketDOMRefs.portfolioValue) {
      let totalValue = (d.market.ksptToken.owned * d.market.ksptToken.price);
      if (d.market.banxToken) {
        totalValue += (d.market.banxToken.owned * d.market.banxToken.price);
      }
      if (d.market.personalToken) {
        totalValue += (d.market.personalToken.owned * d.market.personalToken.price);
      }
      marketDOMRefs.portfolioValue.textContent = totalValue.toFixed(2) + " KSPT";
    }
  } else if (currentMarketView === 'trade' && selectedToken) {
    let tokenData;
    if (selectedToken === 'ksptToken') {
      tokenData = d.market.ksptToken;
    } else if (selectedToken === 'banxToken') {
      tokenData = d.market.banxToken;
    } else if (selectedToken === 'personalToken') {
      tokenData = d.market.personalToken;
    }
    
    if (tokenData && marketDOMRefs.priceContainer && marketDOMRefs.priceArrow) {
      const lastPrice = tokenData.history[tokenData.history.length - 2] || tokenData.price;
      const diff = tokenData.price - lastPrice;
      const colorClass = diff >= 0 ? "price-up" : "price-down";
      const arrow = diff >= 0 ? "▲" : "▼";
      
      if (marketDOMRefs.tradeAmount) {
        const priceValueElem = marketDOMRefs.tradeAmount.parentElement?.parentElement?.querySelector('#trade-price-value');
        if (priceValueElem) {
          priceValueElem.textContent = selectedToken === 'ksptToken' ? 
            tokenData.price.toFixed(2) : tokenData.price.toFixed(4);
        }
      }
      
      marketDOMRefs.priceContainer.className = colorClass;
      marketDOMRefs.priceArrow.textContent = arrow;
    }
    
    // BUGFIX 1: Update chart in-place
    if (marketDOMRefs.chartCanvas) {
      drawChart();
    }
  }
  
  // BUGFIX 1: Restore input state
  if (marketDOMRefs.tradeAmount && inputValue !== undefined) {
    marketDOMRefs.tradeAmount.value = inputValue;
    try {
      marketDOMRefs.tradeAmount.setSelectionRange(inputSelection.start, inputSelection.end);
    } catch(e) {
      console.debug('market:restore-selection-failed', e);
    }
    if (hadFocus) {
      marketDOMRefs.tradeAmount.focus();
    }
  }
  
  console.debug('market:update tick', Date.now());
}

// BUGFIX 2: Update individual token prices
function updateTokenPriceData(tokenKey) {
  const token = d.market[tokenKey];
  if (!token) return;
  
  const now = Date.now();
  let updateInterval;
  if (tokenKey === 'ksptToken') updateInterval = 30000;
  else if (tokenKey === 'banxToken') updateInterval = 20000;
  else if (tokenKey === 'personalToken') updateInterval = 15000 + Math.random() * 10000;
  
  if (now - token.lastUpdate >= updateInterval) {
    token.lastUpdate = now;
    
    let change = 0;
    let isSpike = Math.random() < 0.05;
    let sign = Math.random() < 0.5 ? -1 : 1;
    
    if (tokenKey === 'ksptToken') {
      if (isSpike) {
        change = (Math.random() * 0.15) + 0.15;
      } else {
        change = (Math.random() * 0.04) + 0.01;
      }
    } else if (tokenKey === 'banxToken') {
      if (isSpike) {
        change = (Math.random() * 0.0002) + 0.0006;
      } else {
        change = (Math.random() * 0.0002) + 0.0002;
      }
    } else if (tokenKey === 'personalToken') {
      if (isSpike) {
        change = token.price * ((Math.random() * 0.05) + 0.10);
      } else {
        change = token.price * ((Math.random() * 0.05) + 0.03);
      }
    }
    
    let newPrice = token.price + (change * sign);
    
    // Apply limits
    if (tokenKey === 'ksptToken') {
      if (newPrice < 0.10) newPrice = 0.10;
      if (newPrice > 2.80) newPrice = 2.80;
    } else if (tokenKey === 'banxToken') {
      if (newPrice < 0.0007) newPrice = 0.0007;
      if (newPrice > 0.01) newPrice = 0.01;
    } else if (tokenKey === 'personalToken') {
      if (newPrice < 0.001) newPrice = 0.001;
      if (newPrice > 10) newPrice = 10;
    }
    
    token.price = newPrice;
    token.history.push(newPrice);
    if (token.history.length > 20) token.history.shift();
  }
}

function updateMarketUI() {
  const container = document.getElementById("marketContainer");
  if (!container) return;
  
  if (!d.market.introSeen) {
    container.innerHTML = `
      <div class="market-intro">
        <h1>Welcome to the Exchange!</h1>
        <p style="color:#aaa; margin-bottom: 30px;">Trade KSP TOKEN (Fake!) in a volatile market.</p>
        <div style="font-size: 50px; margin-bottom:30px;">📈</div>
        <button onclick="enterMarket()">Start</button>
      </div>
    `;
    return;
  }
  
  if (currentMarketView === 'main') {
    let totalValue = (d.market.ksptToken.owned * d.market.ksptToken.price);
    if (d.market.banxToken) {
      totalValue += (d.market.banxToken.owned * d.market.banxToken.price);
    }
    if (d.market.personalToken) {
      totalValue += (d.market.personalToken.owned * d.market.personalToken.price);
    }
    
    let deleteButtonHTML = '';
    if (d.market.personalToken) {
      const now = Date.now();
      const created = d.market.personalToken.createdAt;
      const hoursPassed = (now - created) / (1000 * 60 * 60);
      const canDelete = hoursPassed >= 24;
      
      deleteButtonHTML = `
        <button onclick="deletePersonalToken()" style="margin-top:10px; background:#d32f2f; color:#fff; ${!canDelete ? 'opacity:0.5;' : ''}">
          ${canDelete ? 'Delete Personal Token' : 'Delete Token (Available in ' + Math.ceil(24 - hoursPassed) + 'h)'}
        </button>
      `;
    }
    
    container.innerHTML = `
      <div class="account-box">
        <div class="acc-header">
          <div>
            <div class="acc-name">${d.market.account.name}</div>
            <div class="acc-desc">${d.market.account.desc}</div>
          </div>
          <button class="acc-edit-btn" onclick="editAccount()">Edit</button>
        </div>
        <div class="portfolio-row">
          <span>KSPT Balance:</span>
          <span style="color:#2e7d32">${d.tokens.toFixed(2)}</span>
        </div>
        <div class="portfolio-row">
          <span>Portfolio Value:</span>
          <span id="market-portfolio-value">${totalValue.toFixed(2)} KSPT</span>
        </div>
        ${d.market.personalToken ? '' : '<button onclick="createPersonalToken()" style="margin-top:10px; background:#ff9800; color:#000;">Create Personal Token (899 KSPT)</button>'}
        ${deleteButtonHTML}
      </div>
      
      <div class="card-title">Cryptocurrencies</div>
      
      <div class="market-list-item" onclick="openTrade('ksptToken')">
        <img src="kspt.png" class="token-icon">
        <div class="token-info">
          <div class="token-name">KSP TOKEN</div>
          <div class="token-price" id="price-ksptToken">
            Price: <span id="price-ksptToken-value">${d.market.ksptToken.price.toFixed(2)}</span> KSPT
          </div>
        </div>
        <div>></div>
      </div>
      
      <div class="market-list-item" onclick="openTrade('banxToken')">
        <img src="bandit.png" class="token-icon" onerror="this.src='kspt.png'">
        <div class="token-info">
          <div class="token-name">BANX</div>
          <div class="token-price" id="price-banxToken">
            Price: <span id="price-banxToken-value">${d.market.banxToken.price.toFixed(4)}</span> KSPT
          </div>
        </div>
        <div>></div>
      </div>
      
      ${d.market.personalToken ? `
      <div class="market-list-item" onclick="openTrade('personalToken')">
        <img src="${d.market.personalToken.icon || 'what.png'}" class="token-icon" onerror="this.src='kspt.png'">
        <div class="token-info">
          <div class="token-name">${d.market.personalToken.ticker || 'PERS'}</div>
          <div class="token-price" id="price-personalToken">
            Price: <span id="price-personalToken-value">${d.market.personalToken.price.toFixed(4)}</span> KSPT
          </div>
        </div>
        <div>></div>
      </div>
      ` : ''}
    `;
    
    // BUGFIX 1: Initialize market references after DOM update
    setTimeout(initMarketReferences, 0);
  } else if (currentMarketView === 'trade') {
    renderTradeView();
  } else if (currentMarketView === 'createToken') {
    renderTokenCreationForm();
  }
}

// BUGFIX 1: Custom keyboard for trade view
function setupCustomKeyboard() {
  const keyboard = document.getElementById('customKeyboard');
  const keys = keyboard.querySelectorAll('.keyboard-key');
  
  keys.forEach(key => {
    key.addEventListener('click', function() {
      const keyValue = this.getAttribute('data-key');
      const input = currentKeyboardInput;
      
      if (!input) return;
      
      if (keyValue === 'backspace') {
        input.value = input.value.slice(0, -1);
      } else if (keyValue === 'done') {
        hideCustomKeyboard();
      } else if (keyValue === '.') {
        if (!input.value.includes('.')) {
          input.value += '.';
        }
      } else {
        input.value += keyValue;
      }
      
      input.dispatchEvent(new Event('input', { bubbles: true }));
    });
  });
}

function showCustomKeyboard(inputElement) {
  currentKeyboardInput = inputElement;
  const keyboard = document.getElementById('customKeyboard');
  keyboard.classList.add('active');
  
  inputElement.blur();
  inputElement.readOnly = true;
  
  keyboard.style.bottom = '65px';
}

function hideCustomKeyboard() {
  const keyboard = document.getElementById('customKeyboard');
  keyboard.classList.remove('active');
  
  if (currentKeyboardInput) {
    currentKeyboardInput.readOnly = false;
    currentKeyboardInput = null;
  }
}

// BUGFIX 2: Custom token image selection with cropping
function handleTokenImageSelection(file) {
  if (!file || !file.type.match('image.*')) {
    showToast("Please select a valid image file");
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      cropData.image = img;
      cropData.scale = 100;
      cropData.x = 0;
      cropData.y = 0;
      
      const cropModal = document.getElementById('cropModal');
      const cropImage = document.getElementById('cropImage');
      const cropZoom = document.getElementById('cropZoom');
      
      cropImage.src = e.target.result;
      cropZoom.value = 100;
      
      cropModal.classList.add('active');
      
      setupCropInteractions();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

function setupCropInteractions() {
  const cropImage = document.getElementById('cropImage');
  const cropZoom = document.getElementById('cropZoom');
  
  cropZoom.oninput = function() {
    cropData.scale = parseInt(this.value);
    updateCropImage();
  };
  
  let isDragging = false;
  let startX, startY;
  
  cropImage.addEventListener('mousedown', startDrag);
  cropImage.addEventListener('touchstart', function(e) {
    e.preventDefault();
    const touch = e.touches[0];
    startDrag({ clientX: touch.clientX, clientY: touch.clientY });
  });
  
  function startDrag(e) {
    isDragging = true;
    startX = e.clientX - cropData.x;
    startY = e.clientY - cropData.y;
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      drag({ clientX: touch.clientX, clientY: touch.clientY });
    });
    
    document.addEventListener('mouseup', stopDrag);
    document.addEventListener('touchend', stopDrag);
  }
  
  function drag(e) {
    if (!isDragging) return;
    cropData.x = e.clientX - startX;
    cropData.y = e.clientY - startY;
    updateCropImage();
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', stopDrag);
  }
  
  updateCropImage();
}

function updateCropImage() {
  const cropImage = document.getElementById('cropImage');
  if (!cropImage) return;
  
  const scale = cropData.scale / 100;
  cropImage.style.transform = `translate(${cropData.x}px, ${cropData.y}px) scale(${scale})`;
}

function cancelCrop() {
  const cropModal = document.getElementById('cropModal');
  cropModal.classList.remove('active');
  cropData.image = null;
}

function applyCrop() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  canvas.width = 200;
  canvas.height = 200;
  
  ctx.save();
  ctx.beginPath();
  ctx.arc(100, 100, 100, 0, Math.PI * 2);
  ctx.closePath();
  ctx.clip();
  
  const img = cropData.image;
  const scale = cropData.scale / 100;
  const containerSize = 300;
  
  const srcX = -cropData.x / scale;
  const srcY = -cropData.y / scale;
  const srcSize = containerSize / scale;
  
  ctx.drawImage(img, srcX, srcY, srcSize, srcSize, 0, 0, 200, 200);
  
  ctx.restore();
  
  const dataURL = canvas.toDataURL('image/png');
  
  tokenImageCache = dataURL;
  localStorage.setItem('kspt_token_image_cache', dataURL);
  
  const preview = document.getElementById('tokenImagePreview');
  if (preview) {
    preview.style.backgroundImage = `url('${dataURL}')`;
    preview.dataset.imageData = dataURL;
  }
  
  cancelCrop();
  showToast("Image cropped and saved!");
}

// BUGFIX 1: Render trade view with custom keyboard
function renderTradeView() {
  const container = document.getElementById("marketContainer");
  if (!container) return;
  
  let tokenData, tokenName, tokenIcon;
  
  if (selectedToken === 'ksptToken') {
    tokenData = d.market.ksptToken;
    tokenName = "KSP TOKEN";
    tokenIcon = "kspt.png";
  } else if (selectedToken === 'banxToken') {
    tokenData = d.market.banxToken;
    tokenName = "BANX";
    tokenIcon = "bandit.png";
  } else if (selectedToken === 'personalToken') {
    tokenData = d.market.personalToken;
    tokenName = tokenData.ticker || 'PERS';
    tokenIcon = tokenData.icon || 'what.png';
  } else {
    return;
  }
  
  const lastPrice = tokenData.history[tokenData.history.length - 2] || tokenData.price;
  const diff = tokenData.price - lastPrice;
  const colorClass = diff >= 0 ? "price-up" : "price-down";
  const arrow = diff >= 0 ? "▲" : "▼";
  
  container.innerHTML = `
    <div class="top-bar">
      ${tokenIcon.startsWith('data:') ? 
        `<img src="${tokenIcon}" style="width:32px;height:32px;border-radius:50%;" onerror="this.src='kspt.png'">` :
        `<img src="${tokenIcon}" onerror="this.src='kspt.png'">`
      }
      <span style="font-weight:bold">${tokenName}</span>
      <img src="iks.png" class="close-x" onclick="closeTrade()">
    </div>
    
    <div class="card">
      <div id="trade-price-container" style="font-size: 32px; font-weight:bold; text-align:center; margin-bottom:5px;" class="${colorClass}">
        <span id="trade-price-value">${selectedToken === 'ksptToken' ? tokenData.price.toFixed(2) : tokenData.price.toFixed(4)}</span> KSPT 
        <span id="trade-price-arrow" style="font-size:16px">${arrow}</span>
      </div>
      <div style="text-align:center; color:#666; font-size:12px; margin-bottom:15px;">Live Price</div>
      
      <div class="chart-container" id="chartBox">
        <canvas id="priceChart" class="chart-canvas"></canvas>
        <div id="chartTooltip" class="price-tooltip"></div>
      </div>
    </div>
    
    <div class="card">
      <div class="card-title">Your Holdings</div>
      <div class="button-row" style="margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:10px;">
        <div>Owned: <span style="color:#ff9800">${tokenData.owned.toFixed(2)}</span></div>
        <div>Value: ${(tokenData.owned * tokenData.price).toFixed(2)} KSPT</div>
      </div>
      
      <div class="input-group">
        <input type="text" id="tradeAmount" placeholder="Amount" readonly onfocus="showCustomKeyboard(this)">
      </div>
      
      <div class="button-row">
        <button style="background:#2e7d32" onclick="buyToken()">Buy (KSPT)</button>
        <button style="background:#d32f2f" onclick="sellToken()">Sell</button>
      </div>
      <div style="text-align:center; font-size:11px; color:#666; margin-top:5px;">
        Buy Limit: ${selectedToken === 'ksptToken' ? '5 - 200' : selectedToken === 'banxToken' ? '0.01 - 50' : '0.1 - 100'} KSPT | Sell Cooldown: 2m
      </div>
      <div id="buyCooldownInfo" style="text-align:center; font-size:11px; color:#666; margin-top:5px;"></div>
    </div>
  `;
  
  // BUGFIX 1: Initialize references after DOM is built
  setTimeout(() => {
    initMarketReferences();
    drawChart();
  }, 50);
  
  updateBuyCooldownInfo();
}

function updateBuyCooldownInfo() {
  const now = Date.now();
  const timeSinceLastBuy = now - lastMarketBuyTime;
  const cooldownRemaining = 30000 - timeSinceLastBuy; // BUGFIX 5: Changed from 10000 to 30000
  
  const cooldownElem = document.getElementById("buyCooldownInfo");
  if (cooldownElem) {
    if (cooldownRemaining > 0) {
      cooldownElem.textContent = `Buy Cooldown: ${(cooldownRemaining/1000).toFixed(1)}s`;
      cooldownElem.style.color = "#d32f2f";
    } else {
      cooldownElem.textContent = "Buy Cooldown: Ready";
      cooldownElem.style.color = "#2e7d32";
    }
  }
}

function renderTokenCreationForm() {
  const container = document.getElementById("marketContainer");
  if (!container) return;
  
  let imagePreview = tokenImageCache || 'what.png';
  
  container.innerHTML = `
    <div class="top-bar">
      <img src="what.png">
      <span style="font-weight:bold">Create Personal Token</span>
      <img src="iks.png" class="close-x" onclick="closeTokenCreation()">
    </div>
    
    <div class="card">
      <div class="card-title">Token Details</div>
      <div class="card-sub">Create your own cryptocurrency token</div>
      
      <div style="margin-bottom: 10px;">
        <div style="font-size: 13px; margin-bottom: 5px; color: #aaa;">Ticker (3-5 characters)</div>
        <input type="text" id="tokenTicker" placeholder="PERS" maxlength="5">
      </div>
      
      <div style="margin-bottom: 10px;">
        <div style="font-size: 13px; margin-bottom: 5px; color: #aaa;">Name (max 20 characters)</div>
        <input type="text" id="tokenName" placeholder="My Personal Token" maxlength="20">
      </div>
      
      <div style="margin-bottom: 10px;">
        <div style="font-size: 13px; margin-bottom: 5px; color: #aaa;">Description (10-250 characters)</div>
        <input type="text" id="tokenDesc" placeholder="A personal token created by me">
      </div>
      
      <div style="margin-bottom: 10px;">
        <div style="font-size: 13px; margin-bottom: 5px; color: #aaa;">Supply (100-99999)</div>
        <input type="number" id="tokenSupply" placeholder="1000" min="100" max="99999">
      </div>
      
      <div style="margin-bottom: 15px;">
        <div style="font-size: 13px; margin-bottom: 5px; color: #aaa;">Token Icon (Optional)</div>
        <div id="tokenImagePreview" style="width: 60px; height: 60px; background: #222; border-radius: 50%; margin-bottom: 10px; background-size: cover; background-position: center; background-image: url('${imagePreview}');"></div>
        <input type="file" id="tokenImageUpload" accept="image/*" style="display: none;">
        <button onclick="document.getElementById('tokenImageUpload').click()" style="width: auto; padding: 8px 15px; background: #444; margin-bottom: 10px;">Upload Image</button>
        <div style="font-size: 11px; color: #666;">If no image is uploaded, default icon will be used</div>
      </div>
      
      <div style="border-top: 1px solid #333; padding-top: 15px; margin-top: 15px;">
        <div style="font-size: 13px; margin-bottom: 10px; color: #aaa;">Creation Cost: <span style="color: #ff9800;">899 KSPT</span></div>
        <button onclick="confirmTokenCreation()" style="background: #ff9800; color: #000; font-weight: bold;">Create Token</button>
        <button onclick="closeTokenCreation()" style="margin-top: 8px; background: #444;">Cancel</button>
      </div>
    </div>
  `;
  
  const fileInput = document.getElementById('tokenImageUpload');
  if (fileInput) {
    fileInput.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        handleTokenImageSelection(file);
      }
    };
  }
  
  const preview = document.getElementById('tokenImagePreview');
  if (preview && tokenImageCache) {
    preview.dataset.imageData = tokenImageCache;
  }
}

function closeTokenCreation() {
  currentMarketView = 'main';
  updateMarketUI();
}

function confirmTokenCreation() {
  const ticker = document.getElementById('tokenTicker')?.value.trim().toUpperCase();
  const name = document.getElementById('tokenName')?.value.trim();
  const description = document.getElementById('tokenDesc')?.value.trim();
  const supply = parseInt(document.getElementById('tokenSupply')?.value);
  
  if (!ticker || ticker.length < 3 || ticker.length > 5) {
    showToast("Ticker must be 3-5 characters!");
    return;
  }
  
  if (!name || name.length > 20) {
    showToast("Name must be 1-20 characters!");
    return;
  }
  
  if (!description || description.length < 10 || description.length > 250) {
    showToast("Description must be 10-250 characters!");
    return;
  }
  
  if (!supply || supply < 100 || supply > 99999) {
    showToast("Supply must be between 100 and 99999!");
    return;
  }
  
  if (d.tokens < 899) {
    showToast("Need 899 KSPT to create a personal token!");
    return;
  }
  
  let icon = 'what.png';
  const preview = document.getElementById('tokenImagePreview');
  if (preview && preview.dataset.imageData) {
    icon = preview.dataset.imageData;
  }
  
  const initialPrice = 899 / supply;
  
  if (confirm(`Create token?\n\nTicker: ${ticker}\nName: ${name}\nSupply: ${supply}\nInitial Price: ${initialPrice.toFixed(4)} KSPT\nCost: 899 KSPT`)) {
    d.tokens -= 899;
    d.market.personalToken = {
      ticker: ticker,
      name: name,
      description: description,
      creatorName: d.market.account.name,
      supply: supply,
      owned: 0,
      lastBuyTime: 0,
      price: initialPrice,
      history: Array(5).fill(initialPrice),
      lastUpdate: Date.now(),
      icon: icon,
      createdAt: Date.now()
    };
    
    tokenImageCache = null;
    localStorage.removeItem('kspt_token_image_cache');
    
    showToast("Personal Token Created!");
    save();
    currentMarketView = 'main';
    updateMarketUI();
    ui();
  }
}

function drawChart() {
  const canvas = document.getElementById("priceChart");
  if (!canvas) return;
  
  const ctx = canvas.getContext("2d");
  const container = document.getElementById("chartBox");
  if (!container) return;
  
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  
  let history = [];
  if (selectedToken === 'ksptToken') {
    history = d.market.ksptToken.history;
  } else if (selectedToken === 'banxToken') {
    history = d.market.banxToken.history;
  } else if (selectedToken === 'personalToken' && d.market.personalToken) {
    history = d.market.personalToken.history;
  }
  
  if (history.length < 2) return;
  
  let min = Math.min(...history);
  let max = Math.max(...history);
  let range = max - min;
  if (range === 0) range = 1;
  
  let padding = 20;
  let w = canvas.width;
  let h = canvas.height;
  
  ctx.clearRect(0, 0, w, h);
  
  ctx.beginPath();
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 2;
  
  let points = [];
  for (let i = 0; i < history.length; i++) {
    let x = (i / (history.length - 1)) * (w - 2 * padding) + padding;
    let y = h - ((history[i] - min) / range) * (h - 2 * padding) - padding;
    points.push({x, y, val: history[i], prev: history[Math.max(0, i - 1)]});
    
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  points.forEach(p => {
    ctx.beginPath();
    ctx.fillStyle = "#fff";
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fill();
  });
  
  canvas.onclick = function(e) {
    let rect = canvas.getBoundingClientRect();
    let clickX = e.clientX - rect.left;
    
    let closest = points.reduce((prev, curr) => {
      return (Math.abs(curr.x - clickX) < Math.abs(prev.x - clickX) ? curr : prev);
    });
    
    let change = closest.val - closest.prev;
    let sign = change >= 0 ? "+" : "";
    let txt = `Price: ${closest.val.toFixed(4)} (${sign}${change.toFixed(4)})`;
    
    let tooltip = document.getElementById("chartTooltip");
    if (tooltip) {
      tooltip.style.display = "block";
      tooltip.style.left = (closest.x - 40) + "px";
      tooltip.style.top = (closest.y - 30) + "px";
      tooltip.textContent = txt;
      
      setTimeout(() => tooltip.style.display = "none", 2000);
    }
  };
}

// ==========================================
// ОСНОВНЫЕ ФУНКЦИОНАЛЬНЫЕ ФУНКЦИИ
// ==========================================

function openScreen(id) {
  document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
  document.getElementById(id)?.classList.add("active");
  
  if (id === 'settings') {
    showSettingsSub('main');
  }
  
  document.querySelectorAll(".nav-item").forEach(n => n.classList.remove("active"));
  if (id === 'main') {
    document.getElementById('navMain')?.classList.add("active");
    if (marketUpdateInterval) {
      clearInterval(marketUpdateInterval);
      marketUpdateInterval = null;
      console.debug('market: interval stopped');
    }
    hideCustomKeyboard();
  } else if (id === 'market') {
    document.getElementById('navMarket')?.classList.add("active");
    if (!marketUpdateInterval) {
      marketUpdateInterval = setInterval(updateMarketPrices, 1000);
      console.debug('market: interval started');
    }
    // BUGFIX 1: Initialize market references when market opens
    setTimeout(initMarketReferences, 100);
  } else {
    hideCustomKeyboard();
    if (marketUpdateInterval) {
      clearInterval(marketUpdateInterval);
      marketUpdateInterval = null;
      console.debug('market: interval stopped');
    }
  }
  
  ui();
  d.lastLogin = Date.now();
  save();
}

function showSettingsSub(sub) {
  const subs = ["settings-main", "settings-sound", "settings-bg"];
  subs.forEach(s => {
    const elem = document.getElementById(s);
    if (elem) elem.style.display = "none";
  });
  
  const target = document.getElementById("settings-" + sub);
  if (target) target.style.display = "block";
}

function showToast(msg) {
  const t = document.getElementById("toast");
  if (!t) return;
  
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 2000);
}

// ==========================================
// ОБРАБОТКА КЛИКОВ И ГЕЙМПЛЕЙ
// ==========================================

document.getElementById('coin')?.addEventListener('touchstart', function(e) {
  if (e.touches.length > 2) {
    e.preventDefault();
    return false;
  }
}, {passive: false});

const coin = document.getElementById('coin');
if (coin) {
  coin.addEventListener("touchstart", () => {
    if (d.vibration === "off") return;
    let dur = 30;
    if (d.vibration === 'low') dur = 10;
    if (d.vibration === 'strong') dur = 50;
    
    if (navigator.vibrate) {
      navigator.vibrate(dur);
    }
  }, { passive: true });
  
  coin.onclick = function(e) {
    if (cheatStage >= 3) return;
    
    let m = d.x2 ? 2 : 1;
    const now = Date.now();
    
    if (d.boost.active && now < d.boost.end) {
      m *= 10;
    } else if (d.bonuses.tap2x.active && now < d.bonuses.tap2x.end) {
      m *= 2;
    }
    
    // Energy consumption based on multiplier
    let cost = 1; // x1 multiplier → 1 energy
    if (m === 2) {
      cost = 2; // x2 multiplier → 2 energy
    } else if (m >= 10) {
      cost = 3; // x10-x20 multiplier → 3 energy
    }
    
    if (d.energy < cost) return;
    
    lastTapTime = now;
    
    if (isWarningActive) return;
    
    clickTimes.push(now);
    clickTimes = clickTimes.filter(t => now - t <= 6500);
    if (clickTimes.length > 100) {
      handleCheatDetection();
      return;
    }
    
    d.energy -= cost;
    let earned = 0.01 * m;
    d.tokens += earned;
    
    showTapFloat(e, earned);
    handleSkinAnimation(); // BUGFIX 3: Only called on tap
    
    coin.classList.add('anim');
    setTimeout(() => coin.classList.remove('anim'), 80);
    
    d.lastLogin = now;
    save();
    ui();
  };
}

function showTapFloat(e, amount) {
  let el = document.createElement("div");
  el.className = "tap-text";
  el.textContent = "+" + amount.toFixed(2);
  
  let x, y;
  if (e && e.clientX) {
    x = e.clientX;
    y = e.clientY;
  } else {
    let rect = coin.getBoundingClientRect();
    x = rect.left + rect.width / 2;
    y = rect.top + rect.height / 2;
  }
  
  el.style.left = (x - 20) + "px";
  el.style.top = (y - 40) + "px";
  
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 500);
}

// BUGFIX 3: Make animation happen only on tap - Already replaced above

function handleCheatDetection() {
  if (cheatStage === 0) {
    document.getElementById("cheatWarningModal").style.display = "flex";
    isWarningActive = true;
    clickTimes = [];
  } else if (cheatStage === 1) {
    d = JSON.parse(JSON.stringify(defaultData));
    d.market = {
      introSeen: false,
      account: { name: "Trader", desc: "Crypto enthusiast" },
      ksptToken: { owned: 0, lastBuyTime: 0, price: 0.50, history: [0.5, 0.5, 0.5, 0.5, 0.5], lastUpdate: Date.now() },
      banxToken: { owned: 0, lastBuyTime: 0, price: 0.0021, history: [0.0021, 0.0021, 0.0021, 0.0021, 0.0021], lastUpdate: Date.now() },
      personalToken: null
    };
    save();
    showToast("Account Reset due to cheating!");
    cheatStage = 2;
    localStorage.setItem("kspt_cheat_stage", 2);
    clickTimes = [];
    ui();
  } else if (cheatStage >= 2) {
    cheatStage = 3;
    localStorage.setItem("kspt_cheat_stage", 3);
    document.getElementById("redScreen").style.display = "flex";
  }
}

function dismissWarning() {
  document.getElementById("cheatWarningModal").style.display = "none";
  cheatStage = 1;
  localStorage.setItem("kspt_cheat_stage", 1);
  clickTimes = [];
  isWarningActive = false;
}

function attemptUnban() {
  const key = document.getElementById("unbanInput")?.value.trim();
  if (key === "Stupid_green") {
    cheatStage = 0;
    localStorage.setItem("kspt_cheat_stage", 0);
    document.getElementById("redScreen").style.display = "none";
    showToast("Ban removed. Be careful.");
    clickTimes = [];
  } else {
    showToast("Invalid Key.");
  }
}

// ==========================================
// ПОКУПКИ И УЛУЧШЕНИЯ
// ==========================================

function buySkin(s, c) {
  if (s === "default") {
    d.skin = "default";
  } else if (s === "priz") {
    if (d.wonX10 && globalSkinLimit > 0) d.skin = "priz";
  } else if (d.skins[s]) {
    if (s === "euro") {
      d.euroVar = d.euroVar === 1 ? 2 : 1;
    }
    d.skin = s;
  } else {
    let finalPrice = c;
    if (d.bonuses.discounts && d.bonuses.discounts[s] && Date.now() < d.bonuses.discounts[s]) {
      finalPrice = Math.floor(c * 0.85);
    }
    
    if (d.tokens >= finalPrice) {
      d.tokens -= finalPrice;
      d.skins[s] = 1;
      d.skin = s;
      
      // BUGFIX: Add Chrispy Candle when buying Crypto Cookie
      if (s === "cookie") {
        d.skins['chrisp'] = 1; // grant accessory / bonus item
      }
      
      if (s === "space" && !d.ownedBgs.includes("space")) {
        d.ownedBgs.push("space");
      }
      
      if (s === "pixe" && !d.ownedBgs.includes('bug')) {
        d.ownedBgs.push('bug');
        showToast("Bonus! Background 'Dead Pixel' Unlocked!");
      }
      
      showToast("Purchase successful.");
    }
  }
  // BUGFIX 3: Update skin image and initialize animation
  updateSkinImage();
  save();
  ui();
}

function buyCard(id) {
  let key = "c" + id;
  let curLvl = d.cards[key];
  if (curLvl >= 5) return;
  
  let nextLvl = curLvl + 1;
  let cost = CARDS[id].levels[nextLvl].price;
  
  if (d.tokens >= cost) {
    d.tokens -= cost;
    d.cards[key] = nextLvl;
    showToast("Purchase Successful");
    save();
    ui();
  }
}

function buyX2() {
  if (!d.x2 && d.tokens >= 5) {
    d.tokens -= 5;
    d.x2 = true;
    showToast("Purchase successful.");
    save();
    ui();
  }
}

function buyTempBoost() {
  const now = Date.now();
  if (now < d.boost.cdEnd) return;
  
  if (d.tokens >= 15) {
    d.tokens -= 15;
    d.boost.active = true;
    d.boost.end = now + 27000;
    d.boost.cdEnd = now + 6000000;
    showToast("Purchase successful.");
    save();
    ui();
  }
}

// BUGFIX 8: Updated regen multiplier with 2.5x and 3x
function buyRegenMult() {
  if (d.regenMult === 1 && d.tokens >= 40) {
    d.tokens -= 40;
    d.regenMult = 1.5;
    showToast("Purchase successful.");
  } else if (d.regenMult === 1.5 && d.tokens >= 70) {
    d.tokens -= 70;
    d.regenMult = 2;
    showToast("Purchase successful.");
  } else if (d.regenMult === 2 && d.tokens >= 140) {
    d.tokens -= 140;
    d.regenMult = 2.5; // BUGFIX 8: Added 2.5x
    showToast("Purchase successful.");
  } else if (d.regenMult === 2.5 && d.tokens >= 140) {
    d.tokens -= 140;
    d.regenMult = 3; // BUGFIX 8: Added 3x
    showToast("Purchase successful.");
  } else if (d.regenMult === 3) {
    showToast("Maximum regeneration reached!");
  }
  save();
  ui();
}

// BUGFIX 8: Updated energy limit with increased cap and costs
function buyEnergyLimit() {
  if (d.maxEnergy >= 10000) { // BUGFIX 8: Increased to 10000
    showToast("Maximum energy limit reached!");
    return;
  }
  
  let cost = 15;
  if (d.maxEnergy >= 8000) {
    cost = 100; // BUGFIX 8: Changed to 100 KSPT
  }
  
  if (d.tokens >= cost) {
    d.tokens -= cost;
    d.maxEnergy += 500;
    showToast("Purchase successful.");
    save();
    ui();
  }
}

function buyBackground(bg, price) {
  if (d.tokens >= price && !d.ownedBgs.includes(bg)) {
    d.tokens -= price;
    d.ownedBgs.push(bg);
    showToast("Purchase successful.");
    save();
    ui();
  }
}

function equipBackground(bg) {
  if (d.ownedBgs.includes(bg)) {
    d.bg = bg;
    save();
    ui();
  }
}

function setVibration(level) {
  d.vibration = level;
  save();
  ui();
}

// ==========================================
// МУЗЫКА
// ==========================================

function playCurrentMusic() {
  if (d.musicMuted) return;
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  
  let src = d.music + ".mp3";
  currentAudio = new Audio(src);
  currentAudio.loop = true;
  currentAudio.volume = 0.5;
  currentAudio.play().catch(e => console.log("Audio play failed:", e));
}

function stopMusic() {
  d.musicMuted = true;
  if (currentAudio) currentAudio.pause();
  save();
  ui();
}

function setMusic(track) {
  if (track === "onion" && !d.skins["onion"]) return;
  if (track === "calm" && !d.ownedMusic.includes("calm")) return;
  if (track !== "mistic" && !d.ownedMusic.includes(track) && track !== "onion") return;
  
  d.music = track;
  d.musicMuted = false;
  if (currentAudio) currentAudio.pause();
  save();
  ui();
  playCurrentMusic();
}

function buyMusic(track, price) {
  if (d.tokens >= price && !d.ownedMusic.includes(track)) {
    d.tokens -= price;
    d.ownedMusic.push(track);
    showToast("Music Unlocked!");
    save();
    ui();
  }
}

function previewMusic(track) {
  if (currentAudio) currentAudio.pause();
  if (previewTimeout) clearTimeout(previewTimeout);
  
  let src = track + ".mp3";
  currentAudio = new Audio(src);
  currentAudio.volume = 0.5;
  currentAudio.play().catch(e => console.log("Preview failed:", e));
  
  previewTimeout = setTimeout(() => {
    if (currentAudio) {
      currentAudio.pause();
      if (!d.musicMuted) playCurrentMusic();
    }
  }, 15000);
}

// ==========================================
// КАПСУЛЫ И ПАЗЛЫ
// ==========================================

function startCapsuleSequence() {
  const modal = document.getElementById("capsuleBreakModal");
  if (modal) modal.classList.add("active");
  capsuleTaps = 0;
  updateCapsuleVisual(0);
}

function updateCapsuleVisual(taps) {
  const img = document.getElementById("capsuleBreakImg");
  if (!img) return;
  
  if (taps === 0) img.src = "capsule.png";
  if (taps === 3) img.src = "capsule1.png";
  if (taps === 8) img.src = "capsule2.png";
  if (taps === 13) img.src = "capsule3.png";
  if (taps === 20) img.src = "capsule4.png";
  if (taps === 30) {
    img.src = "capsule5.png";
    finishCapsuleBreak();
  }
}

document.getElementById("capsuleBreakImg")?.addEventListener('click', function() {
  capsuleTaps++;
  if (capsuleTaps === 3 || capsuleTaps === 8 || capsuleTaps === 13 || capsuleTaps === 20 || capsuleTaps === 30) {
    updateCapsuleVisual(capsuleTaps);
  }
});

function finishCapsuleBreak() {
  const img = document.getElementById("capsuleBreakImg");
  if (!img) return;
  
  img.style.pointerEvents = "none";
  
  setTimeout(() => {
    img.classList.add("zoomed");
    document.getElementById("whiteFade")?.classList.add("active");
    
    setTimeout(() => {
      giveCapsuleReward();
      
      const modal = document.getElementById("capsuleBreakModal");
      if (modal) modal.classList.remove("active");
      
      const fade = document.getElementById("whiteFade");
      if (fade) fade.classList.remove("active");
      
      img.classList.remove("zoomed");
      img.style.pointerEvents = "auto";
    }, 3000);
  }, 500);
}

function giveCapsuleReward() {
  d.capsule.lastOpen = Date.now();
  d.capsule.firstOpen = false;
  
  const rewardTable = [
    { id: '3kspt', weight: 25, type: 'flat' },
    { id: '5kspt', weight: 20, type: 'flat' },
    { id: '10kspt', weight: 15, type: 'sink' },
    { id: '20kspt', weight: 5, type: 'sink' },
    { id: 'coupon', weight: 16, type: 'sink', check: () => true },
    { id: 'offline', weight: 5, type: 'flat' },
    { id: 'tap2x', weight: 3, type: 'flat' },
    { id: 'puzzle', weight: 5, type: 'unique', check: () => !d.puzzleDone },
    { id: 'heaven', weight: 2, type: 'unique', check: () => !d.ownedBgs.includes('heaven') },
    { id: 'skin', weight: 1, type: 'unique', check: () => !d.skins['capsule'] },
    { id: 'music', weight: 10, type: 'unique', check: () => !d.ownedMusic.includes('calm') }
  ];
  
  let redistributionPool = 0;
  let activeRewards = [];
  let sinkCount = 0;
  
  rewardTable.forEach(r => {
    let isValid = true;
    if (r.check && !r.check()) isValid = false;
    
    if (!isValid && r.type === 'unique') {
      redistributionPool += r.weight;
    } else {
      let rClone = {...r};
      activeRewards.push(rClone);
      if (r.type === 'sink') sinkCount++;
    }
  });
  
  if (redistributionPool > 0 && sinkCount > 0) {
    let share = redistributionPool / sinkCount;
    activeRewards.forEach(r => {
      if (r.type === 'sink') {
        r.weight += share;
      }
    });
  }
  
  let totalWeight = activeRewards.reduce((sum, r) => sum + r.weight, 0);
  let rng = Math.random() * totalWeight;
  let runningSum = 0;
  let selected = activeRewards[0];
  
  for (let r of activeRewards) {
    runningSum += r.weight;
    if (rng <= runningSum) {
      selected = r;
      break;
    }
  }
  
  let img = "";
  let txt = "";
  
  switch(selected.id) {
    case '3kspt':
      d.tokens += 3;
      img = "kspt.png";
      txt = "+3 KSPT";
      break;
    case '5kspt':
      d.tokens += 5;
      img = "kspt.png";
      txt = "+5 KSPT";
      break;
    case '10kspt':
      d.tokens += 10;
      img = "kspt.png";
      txt = "+10 KSPT";
      break;
    case '20kspt':
      d.tokens += 20;
      img = "kspt.png";
      txt = "+20 KSPT";
      break;
    case 'coupon':
      let shopSkins = ["what", "burger", "joost", "dog", "diam", "tung", "euro", "space", "pixe", "onion"];
      let unowned = shopSkins.filter(s => !d.skins[s]);
      if (unowned.length > 0) {
        let target = unowned[Math.floor(Math.random() * unowned.length)];
        d.bonuses.discounts[target] = Date.now() + (24 * 60 * 60 * 1000);
        img = "ticket.png";
        txt = `Coupon: -15% on '${target.toUpperCase()}' Skin (24h)`;
      } else {
        d.tokens += 20;
        img = "kspt.png";
        txt = "+20 KSPT (All skins owned)";
      }
      break;
    case 'offline':
      d.bonuses.offline25 = true;
      img = "k.png";
      txt = "+25% Offline Income (One-time)";
      break;
    case 'tap2x':
      d.bonuses.tap2x.active = true;
      d.bonuses.tap2x.end = Date.now() + (2 * 60 * 1000);
      img = "fire.png";
      txt = "Tap x2 for 2 minutes!";
      break;
    case 'puzzle':
      let unownedPz = [];
      for (let i = 0; i < 9; i++) if (d.puzzles[i] === 0) unownedPz.push(i);
      
      if (unownedPz.length > 0) {
        let pick = unownedPz[Math.floor(Math.random() * unownedPz.length)];
        d.puzzles[pick] = 1;
        img = `pazl${pick+1}.png`;
        txt = `Puzzle Piece Found!`;
      } else {
        d.tokens += 15;
        img = "kspt.png";
        txt = "+15 KSPT";
      }
      break;
    case 'heaven':
      d.ownedBgs.push("heaven");
      img = "heaven.png";
      txt = "Background: Heaven";
      break;
    case 'skin':
      d.skins['capsule'] = 1;
      img = "capskine.png";
      txt = "LEGENDARY! Skin: Capsule Master";
      break;
    case 'music':
      d.ownedMusic.push("calm");
      img = "calm.png";
      txt = "New Track: Calm + Hush";
      break;
  }
  
  const rewardImg = document.getElementById("rewardImg");
  const rewardText = document.getElementById("rewardText");
  const rewardPopup = document.getElementById("rewardPopup");
  
  if (rewardImg) rewardImg.src = img;
  if (rewardText) rewardText.textContent = txt;
  if (rewardPopup) rewardPopup.style.display = "block";
  
  save();
  ui();
}

function closeReward() {
  const rewardPopup = document.getElementById("rewardPopup");
  if (rewardPopup) rewardPopup.style.display = "none";
}

function placePuzzlePieces() {
  for (let i = 0; i < 9; i++) {
    if (d.puzzles[i] === 1) {
      const cell = document.getElementById("pz" + (i + 1));
      if (cell) cell.classList.add("filled");
    }
  }
  showToast("Puzzle pieces placed!");
}

// ==========================================
// СТАВКИ
// ==========================================

function setMaxBet() {
  const input = document.getElementById("betAmount");
  if (!input) return;
  
  let max = 30;
  if (d.tokens < 30) max = Math.floor(d.tokens);
  if (max < 1) max = 1;
  input.value = max;
}

function prepareBet(mult, ch) {
  const input = document.getElementById("betAmount");
  if (!input) return;
  
  let a = +input.value;
  if (a < 1 || a > 30 || a > d.tokens) return;
  
  pendingBet = {a, mult, ch};
  const betText = document.getElementById("betText");
  const betConfirm = document.getElementById("betConfirm");
  
  if (betText) betText.textContent = `Bet ${a} KSPT with x${mult}?`;
  if (betConfirm) betConfirm.style.display = "block";
}

function cancelBet() {
  pendingBet = null;
  const betConfirm = document.getElementById("betConfirm");
  if (betConfirm) betConfirm.style.display = "none";
}

function confirmBet() {
  if (!pendingBet) return;
  
  let {a, mult, ch} = pendingBet;
  const betConfirm = document.getElementById("betConfirm");
  if (betConfirm) betConfirm.style.display = "none";
  
  pendingBet = null;
  d.tokens -= a;
  
  if (Math.random() * 100 < ch) {
    d.tokens += a * mult;
    if (mult === 10) {
      if (!d.wonX10 && globalSkinLimit > 0) {
        d.wonX10 = true;
        globalSkinLimit--;
        localStorage.setItem("kspt_global_priz_count", globalSkinLimit);
        showToast("🎉 UNBELIEVABLE! You won x10!\nSkin 'NUMBER #1!' Unlocked!");
      }
    }
  }
  
  save();
  ui();
}

// ==========================================
// ПРОМОКОДЫ
// ==========================================

// BUGFIX 6: Added BezBags promo code
function checkPromo() {
  const input = document.getElementById("promoInput");
  if (!input) return;
  
  const code = input.value.trim();
  if (!code) return;
  
  if (d.usedCodes.includes(code)) {
    showToast("This promo code has already been used.");
    return;
  }
  
  if (code === "ksptshit") {
    if (confirm("Are you sure?") && confirm("WARNING: All coins, skins, and progress will be reset. Proceed?")) {
      localStorage.removeItem("kspt");
      location.reload();
    }
    return;
  }
  
  if (code === "Result0-0") {
    if (confirm("Are you sure? This will reset ONLY your tokens.")) {
      d.tokens = 0;
      save();
      ui();
      showToast("Tokens reset to 0.");
    }
    return;
  }
  
  let reward = 0;
  let valid = false;
  
  switch(code) {
    case "Skibidi":
    case "Brainrot":
      reward = 1;
      valid = true;
      break;
    case "Einarald":
    case "SecEi10":
      reward = 10;
      valid = true;
      break;
    case "Compenation61":
      reward = 61;
      valid = true;
      break;
    case "ComunetiMenagir":
      if (!d.skins['kostia']) {
        d.skins['kostia'] = 1;
        showToast("You found a Secret! Skin 'Special Kostia' Unlocked!");
      }
      valid = true;
      break;
    case "Onyxin":
      reward = 5;
      showToast("Nostalgic...");
      valid = true;
      break;
    case "L1keVideo":
      reward = 5;
      valid = true;
      break;
    case "RedSEKTA":
      if (!d.skins['metka']) {
        d.skins['metka'] = 1;
        showToast("Skin 'KSPT & RED Fingers' Unlocked!");
      }
      valid = true;
      break;
    case "KostinSerial":
      if (!d.skins['seri']) {
        d.skins['seri'] = 1;
        showToast("Secret Skin 'KosTiaP Token' Unlocked!");
      }
      valid = true;
      break;
    case "FreePuzzle":
      let unowned = [];
      for (let i = 0; i < 9; i++) if (d.puzzles[i] === 0) unowned.push(i);
      if (unowned.length > 0) {
        let pick = unowned[Math.floor(Math.random() * unowned.length)];
        d.puzzles[pick] = 1;
        showToast("Puzzle Piece Found!");
        valid = true;
      } else {
        showToast("You already have all puzzle pieces!");
      }
      break;
    // BUGFIX 6: Added BezBags promo code
    case "BezBags":
      if (!d.bonuses.usedBezBags) {
        if (!d.capsule) d.capsule = { lastOpen: 0, firstOpen: true };
        d.capsule.lastOpen = 0;
        d.bonuses.usedBezBags = true;
        showToast("Capsule cooldown skipped! You can open it now.");
        valid = true;
      } else {
        showToast("BezBags promo already used!");
      }
      break;
    default:
      showToast("Invalid code");
      return;
  }
  
  if (valid) {
    if (reward > 0) d.tokens += reward;
    d.usedCodes.push(code);
    save();
    ui();
    if (reward > 0) showToast(`Success! +${reward} KSPT`);
    input.value = "";
  }
}

// ==========================================
// РЫНОК - ФИКСЫ И НОВЫЕ ФУНКЦИИ
// ==========================================

function enterMarket() {
  d.market.introSeen = true;
  save();
  updateMarketUI();
}

function editAccount() {
  let newName = prompt("Enter Display Name:", d.market.account.name);
  if (!newName) return;
  
  let newDesc = prompt("Enter Description (5-80 chars):", d.market.account.desc);
  if (!newDesc || newDesc.length < 5 || newDesc.length > 80) {
    showToast("Description must be between 5 and 80 characters.");
    return;
  }
  
  d.market.account.name = newName;
  d.market.account.desc = newDesc;
  save();
  updateMarketUI();
}

function createPersonalToken() {
  currentMarketView = 'createToken';
  updateMarketUI();
}

function deletePersonalToken() {
  if (!d.market.personalToken) return;
  
  const now = Date.now();
  const created = d.market.personalToken.createdAt;
  const hoursPassed = (now - created) / (1000 * 60 * 60);
  
  if (hoursPassed < 24) {
    showToast(`You can only delete your token 24 hours after creation. ${Math.ceil(24 - hoursPassed)} hours remaining.`);
    return;
  }
  
  let warningMsg = "WARNING: Deleting your token will permanently remove it. ";
  if (d.market.personalToken.owned > 0) {
    warningMsg += `You currently own ${d.market.personalToken.owned.toFixed(2)} tokens. They will be automatically sold at the current price (${d.market.personalToken.price.toFixed(4)} KSPT each). `;
  }
  warningMsg += "The creation cost (899 KSPT) will NOT be refunded.\n\nAre you sure you want to delete your token?";
  
  if (confirm(warningMsg)) {
    if (d.market.personalToken.owned > 0) {
      let earned = d.market.personalToken.owned * d.market.personalToken.price;
      d.tokens += earned;
      showToast(`Sold ${d.market.personalToken.owned.toFixed(2)} tokens for ${earned.toFixed(2)} KSPT.`);
    }
    
    d.market.personalToken = null;
    
    showToast("Personal token deleted. You can create a new one.");
    save();
    updateMarketUI();
    ui();
  }
}

function openTrade(token) {
  selectedToken = token;
  currentMarketView = 'trade';
  updateMarketUI();
}

function closeTrade() {
  currentMarketView = 'main';
  selectedToken = null;
  tradeInputValue = '';
  hideCustomKeyboard();
  updateMarketUI();
}

// BUGFIX 5: Buy cooldown changed from 10s to 30s
function buyToken() {
  const now = Date.now();
  const timeSinceLastBuy = now - lastMarketBuyTime;
  
  // BUGFIX 5: Changed from 10000 to 30000 (10s to 30s)
  if (timeSinceLastBuy < 30000) {
    showToast(`Wait ${(30 - timeSinceLastBuy/1000).toFixed(1)} seconds before buying again.`);
    updateBuyCooldownInfo();
    return;
  }
  
  const input = document.getElementById("tradeAmount");
  if (!input) return;
  
  let amountKSPT = parseFloat(input.value);
  
  let tokenData, minBuy, maxBuy;
  if (selectedToken === 'ksptToken') {
    tokenData = d.market.ksptToken;
    minBuy = 5;
    maxBuy = 200;
  } else if (selectedToken === 'banxToken') {
    tokenData = d.market.banxToken;
    minBuy = 0.01;
    maxBuy = 50;
  } else if (selectedToken === 'personalToken') {
    tokenData = d.market.personalToken;
    minBuy = 0.1;
    maxBuy = 100;
  } else {
    return;
  }
  
  if (isNaN(amountKSPT) || amountKSPT < minBuy || amountKSPT > maxBuy) {
    showToast(`Enter amount between ${minBuy} and ${maxBuy} KSPT`);
    return;
  }
  
  if (d.tokens < amountKSPT) {
    showToast("Not enough KSPT!");
    return;
  }
  
  d.tokens -= amountKSPT;
  let tokensBought = amountKSPT / tokenData.price;
  tokenData.owned += tokensBought;
  tokenData.lastBuyTime = now;
  lastMarketBuyTime = now;
  
  let tokenName = selectedToken === 'ksptToken' ? 'KSP Tokens' : selectedToken === 'banxToken' ? 'BANX' : d.market.personalToken.ticker;
  showToast(`Bought ${tokensBought.toFixed(2)} ${tokenName}`);
  
  save();
  ui();
  updateMarketUI();
}

function sellToken() {
  const now = Date.now();
  const cooldown = 2 * 60 * 1000;
  
  let tokenData;
  if (selectedToken === 'ksptToken') {
    tokenData = d.market.ksptToken;
  } else if (selectedToken === 'banxToken') {
    tokenData = d.market.banxToken;
  } else if (selectedToken === 'personalToken') {
    tokenData = d.market.personalToken;
  } else {
    return;
  }
  
  if (now - tokenData.lastBuyTime < cooldown) {
    let left = Math.ceil((cooldown - (now - tokenData.lastBuyTime)) / 1000);
    showToast(`Wait ${left} seconds to sell.`);
    return;
  }
  
  const input = document.getElementById("tradeAmount");
  if (!input) return;
  
  let amountTokens = parseFloat(input.value);
  if (isNaN(amountTokens) || amountTokens <= 0) {
    showToast("Enter valid amount of tokens");
    return;
  }
  
  if (tokenData.owned < amountTokens) {
    showToast("Not enough tokens owned!");
    return;
  }
  
  tokenData.owned -= amountTokens;
  let earnedKSPT = amountTokens * tokenData.price;
  d.tokens += earnedKSPT;
  
  showToast(`Sold for ${earnedKSPT.toFixed(2)} KSPT`);
  save();
  ui();
  updateMarketUI();
}

// BUGFIX 10: Original marketTicker function kept for compatibility
function marketTicker() {
  console.debug('marketTicker: updating all tokens');
  if (!d.market) return;
  const now = Date.now();
  
  if (now - d.market.ksptToken.lastUpdate >= 30000) {
    d.market.ksptToken.lastUpdate = now;
    let change = 0;
    let isSpike = Math.random() < 0.05;
    let sign = Math.random() < 0.5 ? -1 : 1;
    
    if (isSpike) {
      change = (Math.random() * 0.15) + 0.15;
    } else {
      change = (Math.random() * 0.04) + 0.01;
    }
    
    let newPrice = d.market.ksptToken.price + (change * sign);
    if (newPrice < 0.10) newPrice = 0.10;
    if (newPrice > 2.80) newPrice = 2.80;
    
    d.market.ksptToken.price = newPrice;
    d.market.ksptToken.history.push(newPrice);
    if (d.market.ksptToken.history.length > 20) d.market.ksptToken.history.shift();
  }
  
  if (d.market.banxToken && now - d.market.banxToken.lastUpdate >= 20000) {
    d.market.banxToken.lastUpdate = now;
    let banxChange = 0;
    let banxIsSpike = Math.random() < 0.05;
    let banxSign = Math.random() < 0.5 ? -1 : 1;
    
    if (banxIsSpike) {
      banxChange = (Math.random() * 0.0002) + 0.0006;
    } else {
      banxChange = (Math.random() * 0.0002) + 0.0002;
    }
    
    let newBanxPrice = d.market.banxToken.price + (banxChange * banxSign);
    if (newBanxPrice < 0.0007) newBanxPrice = 0.0007;
    if (newBanxPrice > 0.01) newBanxPrice = 0.01;
    
    d.market.banxToken.price = newBanxPrice;
    d.market.banxToken.history.push(newBanxPrice);
    if (d.market.banxToken.history.length > 20) d.market.banxToken.history.shift();
  }
  
  if (d.market.personalToken && now - d.market.personalToken.lastUpdate >= (15000 + Math.random() * 10000)) {
    d.market.personalToken.lastUpdate = now;
    let personalChangePercent = 0;
    let personalIsSpike = Math.random() < 0.05;
    let personalSign = Math.random() < 0.5 ? -1 : 1;
    
    if (personalIsSpike) {
      personalChangePercent = (Math.random() * 0.05) + 0.10;
    } else {
      personalChangePercent = (Math.random() * 0.05) + 0.03;
    }
    
    let changeAmount = d.market.personalToken.price * personalChangePercent;
    let newPersonalPrice = d.market.personalToken.price + (changeAmount * personalSign);
    
    if (newPersonalPrice < 0.001) newPersonalPrice = 0.001;
    if (newPersonalPrice > 10) newPersonalPrice = 10;
    
    d.market.personalToken.price = newPersonalPrice;
    d.market.personalToken.history.push(newPersonalPrice);
    if (d.market.personalToken.history.length > 20) d.market.personalToken.history.shift();
  }
}

// ==========================================
// ТАЙМЕРЫ И ИНИЦИАЛИЗАЦИЯ
// ==========================================

processOfflineIncome();

setInterval(() => {
  d.lastLogin = Date.now();
  save();
}, 60000);

setInterval(() => {
  const now = Date.now();
  if (now - lastTapTime > 2500) {
    if (d.energy < d.maxEnergy) {
      d.energy += 1 * d.regenMult;
      if (d.energy > d.maxEnergy) d.energy = d.maxEnergy;
      ui();
    }
  }
}, 1500);

setInterval(() => {
  marketTicker();
}, 1000);

document.body.addEventListener('click', function initAudio() {
  if (!d.musicMuted && !currentAudio) {
    playCurrentMusic();
  }
  document.body.removeEventListener('click', initAudio);
}, {once: true});

setupCustomKeyboard();

document.addEventListener('DOMContentLoaded', function() {
  const betInput = document.getElementById('betAmount');
  if (betInput) {
    betInput.readOnly = true;
    betInput.addEventListener('focus', function() {
      showCustomKeyboard(this);
    });
  }
});

// BUGFIX 3: Initialize animations on page load
window.addEventListener('load', function() {
  console.debug('page:load - initializing animations');
  updateSkinImage(); // BUGFIX 3: This will trigger animation initialization
  
  // Initialize market references if market is active
  if (document.getElementById("market")?.classList.contains("active")) {
    initMarketReferences();
  }
  
  ui();
});

ui();
</script>
</body>
</html>
